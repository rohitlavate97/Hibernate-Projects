Hibernate:--> JDBC knowledge + SQL Understanding
Data Persistence:-->Storing data permanently, it has 3 components
-Data--> Represents what to persist
   Raw data
   Java Object
-Medium-->How to persist
   Java I/O Streams
   Serialization/DeSerialization
   JDBC(Java Database Connectivity)
-Storage-->Where to persists
   File
   Database
Note: Flat file->Not related to any technology ex-TXT file
+-------------+        +-------------------+        +-------------+
|   Raw Data  | <----> |   Java I/O Streams| <----> |   Flat File |
+-------------+        +-------------------+        +-------------+

                        (acts as Data Medium)
---------------------------------------------------------------

+--------------+   <-->   +---------------------------+   <-->   +-------------+
|  Java Object |   <-->   | Serialization /           |   <-->   |   Flat File |
|              |           | Deserialization Process   |          |             |
+--------------+           +---------------------------+          +-------------+

-Serialization-->It is a process of converting Java Object into stream of bytes
Note: This Stream of bytes can be stored into a file or can be transferred over a network.(Only serialized object can be sent over the network)
-DeSerialization-->It is the process of converting a streams of bytes into Java Object

Drawback of Using a file as a data storage:-->
-Data Redundancy(Duplication of data)
-Data inconsistency(Data stored in 2 file, modified in 1 file)
-Data Security(May be visible when file open)
-Storage
-No Transaction Support
-No Constraints Support

JDBC(Java DataBase Connectivity)
--------------------------------
+-------------------------+     <----->     +-------------------------+     <----->     +-------------------------+
|  Raw Data / Java Object |                 |          JDBC           |                 |        Database         |
|                         |                 | (Java Database API)     |                 | (MySQL / Oracle / etc.) |
+-------------------------+                 +-------------------------+                 +-------------------------+

CRUD Operations-->Create(Inserting data),Read(Selecting),Update(Modifying),Delete(Removing)

Requirement:-->We have an employee object, which we want to store into data base using JDBC API
    Process:-->Read the data from Employee object by calling Getter method
	           Create a PreparedStatement object of JDBC
			   Now set the data to PreparedStatement and execute it
Note: In Realtime,data is in object, and JDBC is suitable for raw data. JDBC don't have save() or persist() methods. It has executeUpdate()/executeQuery()

Why we need ORM tool?--> Need to transfer Java objects between our app and a db
--------------------
---JDBC
-Saving data(Insert operations)
Employee Object
+-------+-----+------+
| 102   | B   | 6000 |
+-------+-----+------+
       |
       | 1. Call getConnection()
       | 2. PrepareStatement()
       | 3. Set the data
       | 4. Execute it
       v
+-----------------------------+
| Database Table: EMPLOYEE    |
+-------+-----+------+
| 101   | A   | 4000 |
| 102   | B   | 6000 |
+-------+-----+------+

-Retrieving data(select operations)
Technology: JDBC

Steps:
1. Execute query
2. getXXX() (ResultSet methods)
3. Create Employee object
4. Set the data

+-----------------------------+
| Database Table: EMPLOYEE    |
+-------+-----+------+
| 101   | A   | 4000 |
| 102   | B   | 6000 |
+-------+-----+------+
       |
       v
ResultSet
+-------+-----+------+
| 101   | A   | 6000 |
+-------+-----+------+
       |
       v
Employee Object
+-------+-----+------+
| 101   | A   | 6000 |
+-------+-----+------+

---ORM
-Saving Data
Employee Object
+-------+-----+------+
| 102   | B   | 6000 |
+-------+-----+------+
       |
       | save()
       v
+-----------------------------+
| Database Table: EMPLOYEE    |
+-------+-----+------+
| 101   | A   | 4000 |
| 102   | B   | 6000 |
+-------+-----+------+

-Retrieving data
+-----------------------------+
| Database Table: EMPLOYEE    |
+-------+-----+------+
| 101   | A   | 4000 |
| 102   | B   | 6000 |
+-------+-----+------+
       |
       | load()
       v
Employee Object
+-------+-----+------+
| 102   | B   | 6000 |
+-------+-----+------+

--Hibernate(Open Source ORM framework from JBOSS Community)
---------------------------------------
-Transfer objects between our Java app and a database(Both SQL and NoSQL)
-Alternate tools-->TopLink, MyBatis,ORMLite,DataNucleus
-FrameWork provides a set of libraries for the common functionalities of a Java project. so it reduces coding efforts

JPA(Java Persistence API):-->Specification by Sun MicroSystem
-------------------------
Object Model and Relational model are different
To allow developers to switch easily from one ORM tool to another, common specifications provided by SUN Microsystem and ORM tool vendors provided implementation
Most of the JPA Specification is created by taking the features from Hibernate and some features from TopLink
-If we want to migrate form hibernate to MyBatis-->Just configure the Project Config file.

--Feature of Hibernate-->
1)HQL(Hibernate Query Language)-->It is the own query language of Hibernate
-----------------------------
-Hibernate has provided HQL to make the DAO classes as Database independent(SQL queries are database dependent)
-HQL doesn't provide any burden on developer because HQL queries are also looks like SQL queries only
-In SQL Queries, we use column names and table names, But in HQL Queries, we use variables names and class references
Ex:1) (SQL)-->select * from emp
      (HQL)-->select e from Employee e 
   2) (SQL)-->select empno,ename from emp
      (HQL)-->select e.employeeNo,e.employeeName from Employee e

2)Caching
---------
                    +-------------------+
                    | Java Application  |
                    +---------+---------+
                              |
                              v
                    +-------------------+
                    |     Hibernate     |
                    +---------+---------+
                              |
                              v
          +---------------------------------------+
          | Check: Object exists in L1 Cache?     |
          +---------------------------------------+
                       |                 |
                    (YES)              (NO)
                       |                 |
                       v                 v
        +-----------------------+   +-----------------------------------+
        | Return from L1 Cache  |   | Check: Object exists in L2 Cache? |
        +-----------------------+   +-----------------------------------+
                                          |                 |
                                       (YES)              (NO)
                                          |                 |
                                          v                 v
                             +------------------------+   +--------------------+
                             | Copy object to L1      |   |   Fetch from DB    |
                             | Return to Application  |   +--------------------+
                             +------------------------+            |
                                          |                        |
                                          |                        v
                                          |            +------------------------+
                                          |            | Copy object to L2 Cache|
                                          |            +------------------------+
                                          |                        |
                                          +------------<------------+
-Caching improves performance of an application by loading object from cache memory.
In hibernate, 2 levels of cache can be used-->Level 1, Level 2

3) Lazy loading--> By default, Servelet is lazy loaded. Instance varibles are lazy loaded, after object creation it will get memory.
---------------
-When a java app is asking for an object, the Hibernate will create a proxy object and return it to app without loading it from cache/db. when app is accessing the proxy object
then hibernate will laod the real object from db. By doing this hibernate will reduce round trips between app and db
                          ┌────────────────────────────┐
                          │        Application         │
                          │ (Java App accessing data)  │
                          └─────────────┬──────────────┘
                                        │
                    (1) Ask Hibernate for Employee object
                                        │
                                        ▼
                          ┌────────────────────────────┐
                          │         Hibernate          │
                          │ (ORM Framework handling DB)│
                          └─────────────┬──────────────┘
                                        │
                    (2) Creates a Proxy Object for Employee
                                        │
                                        ▼
                          ┌────────────────────────────┐
                          │        Proxy Object        │
                          │ (Placeholder for Employee) │
                          └─────────────┬──────────────┘
                                        │
                    (3) When App Accesses Data (getName, etc.)
                                        │
                                        ▼
                          ┌────────────────────────────┐
                          │         Database           │
                          │ (Fetches Real Employee Data)│
                          └─────────────┬──────────────┘
                                        │
                    (4) Returns Actual Data to Hibernate
                                        │
                                        ▼
                          ┌────────────────────────────┐
                          │        Application         │
                          │ (Now holds Real Object)    │
                          └────────────────────────────┘

4) Connection Pooling--> To get connection with DB--->DriverManager class--->Physical connection, DataSource interface-->Connection pool
---------------------
-Connection pool-->Memory area, buffer,temporary memory where db connections stored(Ready made connections)
-Hibernate has a built-in connection poolling mechanism, where it creates a pool when app is started, maintain it and destroys the pool when app shutdown
┌────────────────────────────┐
│        Java App            │
│  (JDBC / Hibernate / JPA)  │
└─────────────┬──────────────┘
              │
   (1) Request a DB connection
              │
              ▼
┌────────────────────────────┐
│        DataSource          │
│ (Configured in app)        │
│ Acts as bridge to the pool │
└─────────────┬──────────────┘
              │
   (2) Fetch available connection
              │
              ▼
┌────────────────────────────┐
│     Connection Pool        │
│ (HikariCP, C3P0, etc.)     │
│ Pre-created connections:   │
│ [Conn1] [Conn2] [Conn3]... │
└─────────────┬──────────────┘
              │
   (3) Provide one connection
              │
              ▼
┌────────────────────────────┐
│         Database            │
│ Executes SQL queries, etc.  │
└─────────────┬──────────────┘
              │
   (4) Return results to App
              │
              ▼
┌────────────────────────────┐
│        Java App            │
│ Processes results           │
│ and closes connection       │
└─────────────┬──────────────┘
              │
   (5) Connection is **not destroyed** —
       it’s **returned to the pool**
       for **reuse** by next request
              │
              ▼
┌────────────────────────────┐
│     Connection Pool        │
│ Conn1 is now free again    │
└────────────────────────────┘


               ┌────────────────────────────┐
               │      Application Start      │
               └──────────────┬──────────────┘
                              │
                     (1) Hibernate Initialized
                              │
                              ▼
               ┌────────────────────────────┐
               │  Hibernate Connection Pool │
               │   (Built-in Mechanism)     │
               ├────────────────────────────┤
               │ Creates pool of connections│
               │ e.g., [Conn1][Conn2][Conn3]│
               │ Maintains them for reuse   │
               └──────────────┬──────────────┘
                              │
                   (2) Hibernate Sessions use
                        connections from pool
                              │
                              ▼
               ┌────────────────────────────┐
               │         Database            │
               │  (SQL executed via JDBC)    │
               └──────────────┬──────────────┘
                              │
                   (3) When work completes,
                       connection returned to pool
                              │
                              ▼
               ┌────────────────────────────┐
               │  Hibernate Connection Pool │
               │ Connection now reusable    │
               └──────────────┬──────────────┘
                              │
                 (4) Application Shutdown
                              │
                              ▼
               ┌────────────────────────────┐
               │   Pool destroyed, all DB    │
               │   connections closed safely │
               └────────────────────────────┘
5) Criteria---> To get same data from database, we can write different queries. but, a query which returns the data fastly is important.
-----------
-Example--> Query1-->select * from emp;
            Query2-->select empno,ename,sal,deptno from emp; (This is faster)
-In Hibernate, Criteria API is provided to create tuned queries. So an app will fetch data fastly from DB, and hence the performance is improved.

6) Locking--->When two transactions concurrently working on same data, then one transactions made changes should not be overridden by another transactions
----------
-Transaction operations-->Insert, Update and Delete
-By default, multiple transactions can work on the same data concurrently. so it is possible that changes made by one transaction can be overridden by the another transaction
-To prevent it, hibernate has provided locking
-Types of Locking on multiple transactions working on the same data
   Optimistic Locking
   Pessimistic Locking
  
7) Associations: Hibernate Support Associations/relationships
----------------
-OneToMany
-ManyToOne
-ManyToMany
-OneToOne

--Files required for first application
---------------------------------------
-POJO class (Plain Old Java Object)--->class not extending any class or implementing any interface from any API(Hibernate,Struts etc) except java.io.Serializable interface
-----------
example:
        Class A{         ------>POJO Class
		   //variables
		   //methods
		}
		
		Class B extends A{ ------>If base is POJO class then, derived class is also POJO class
		   //variables
		   //methods
		}
Note: Every Java Bean is Pojo Class, but every POJO Class is not a Java Bean class
Note: Java Bean--->Follows below rules
                   -Class must be public
				   -Class must contain default constructor/paramet-less constructor/paramet-less
				   -private memeber should contain setter/getter methods
				   -Class can implement Serializable interface
-Mapping file ---> It is used to map a Java Class with a database table and Java Class variable with table columns
-------------
                   Mapping can be done in 2 ways
                    -XML file(____.hbm.xml)	
                    -annotations(JPA)		
   exmaple:-->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping> 
    <!-- Mapping Java class to table -->
    <class name="com.alchemist.model.Employee" table="employee">
        
        <!-- Primary Key Mapping -->
        <id name="id" column="emp_id">
            <generator class="increment"/>
        </id>
        
        <!-- Other Properties -->
        <property name="name" column="emp_name" type="string"/>
        <property name="department" column="department" type="string"/>  ----->column attribute is optional when property name and column name matching
        <property name="salary" column="salary" type="double"/>
        <property name="joiningDate" column="joining_date" type="date"/>

    </class>
</hibernate-mapping>

					
-Configuration File---> based on number of db's in application
-------------------
-configuraion file is for configuring below things
       -Connection properties
	   -Hibernate properties
	   -Mapping files
	
	Exmaple-->hibernate.cfg.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC 
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>

    <session-factory>

        <!-- Database Connection Settings -->
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/employee_db</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">root</property>

        <!-- JDBC Connection Pooling (Hibernate built-in) -->
        <property name="hibernate.connection.pool_size">10</property>

        <!-- SQL Dialect -->
        <property name="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</property>   --->//Prepare SQL Query to run ob db

        <!-- Optional Settings -->
        <property name="hibernate.show_sql">true</property>        ---->//to log queries
        <property name="hibernate.format_sql">true</property>
        <property name="hibernate.hbm2ddl.auto">update</property>  ----->//to create table if not exists

        <!-- Caching (optional) -->
        <property name="hibernate.cache.use_second_level_cache">false</property>

        <!-- Mapping File -->
        <mapping resource="com/alchemist/model/Employee.hbm.xml"/>   ----->their can be multiple mapping files(1db=1 configuraion file)

    </session-factory>

</hibernate-configuration>

	
--Client Program
---------------
-In SessionFactory object entire configuration metadata will be loaded. Application can't perform CRUD directly using SessionFactory object, Session object(with it hibernate performs operation on db) also created.
-When login with credentials-->One session created in server. when logout-->session closed(session object store information of activity done). Without logout if we close browser,
session is still active, but if we not accessed it for configured time--->server will invalidate session(Session Management)
-SessionFactory creates Session objects depends upon number of requests(5 requests by 5 users-->5 sessions)
--Steps to write the client progream
      -Create a SessionFactory(interface) object
	  -Create a Session object
	  -Create a Transaction object
	  -Perform CRUD operations
	  -Commit/Rollback the Transaction
	  -Close the Session
	  -Close the SessionFactory(No need in real-time application)
Note:-High level object in Hibernate is SessionFactory object, which holds the configuration metadata
     -SessionFactory object is factory for creating Session object
	 -When Session is created, a connection with db is established
	 -A Session object is the main runtime object to perform DB Operations
	 -In Realtime applications, a Session object is created for each request.
	 -A Session object can be used to create a Transaction object.
	 -In Hibernate, Transaction is mandatory to perform insert/update/delete operations. For Select operations, it is optional
	 -End the Transaction with commit/rollback
	 -If no more operations are required, then close the Session
	 -If no more Sessions are required, then close the SessionFactory object

                   ┌────────────────────────────┐
                   │      Application Code       │
                   └─────────────┬───────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 1️⃣ Create SessionFactory (Heavy Object)    │
          │ Reads hibernate.cfg.xml, builds connection  │
          │ pool, metadata, and ORM mapping.            │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 2️⃣ Open Session                            │
          │ Represents a single unit of work with DB.   │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 3️⃣ Begin Transaction                       │
          │ Ensures atomic operation (commit/rollback). │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 4️⃣ Perform CRUD Operations                 │
          │ - session.save()   → Insert                 │
          │ - session.get()    → Read                   │
          │ - session.update() → Update                 │
          │ - session.delete() → Delete                 │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 5️⃣ Commit or Rollback Transaction           │
          │ tx.commit() or tx.rollback()                │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 6️⃣ Close Session                           │
          │ Frees JDBC connection, clears cache.        │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 7️⃣ Close SessionFactory (Optional)         │
          │ Destroys connection pool on app shutdown.   │
          └────────────────────────────────────────────┘
Note: Maven is build tool, it will automate the build process of a Java application. Build process means creating the project structure, adding the jars to projectt classpath, compiling the source code,
      compiling and executing the test cases, packaging the project to jar/war file etc 
	  Archetypes:
	       For Simple Java Project: maven-archetype-quickstart
		   For Web app project: maven-archetypr-webapp
	  Maven Project Co-Ordinates:
	       groupId: a unique id to identify a group of projects of a client
		   artifactId: Project Name
		   version: Project version
	  Pom.xml-->To configure dependency-->Maven will download jars from maven central repo and strore them into local repository(C:/User/Admin/.m2)
	  src/main/java -->source code files
	  src/test/java -->test code files
	  src/main/resources -->for other resources/file(XML/properties/txt)
	  
-First Hibernate Project-->
------------------------
-Create Maven project with maven-archetype-quickstart 
GroupId-->com.alchemist
ArtifactId--> HibernateFirstApp

In pom.xml
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
  </properties>
  
-Add following dependencies
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>6.4.4.Final</version>
</dependency>

<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.4.0</version>
</dependency>

--Create Entity class
public class Student {
	private Integer sid;
	private String sname;
	private String gender;
	private Integer marks;
	//Generate getters and Setters
}

--Create Hibernate mappping file--->student.hbm.xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping>
    <class name="com.alchemist.entity.Student" table="STUDENT">

        <id name="sid" column="SID">
            <generator class="increment"/>
        </id>

        <property name="sname" column="SNAME"/>
        <property name="gender" column="GENDER"/>
        <property name="marks" column="MARKS"/>

    </class>
</hibernate-mapping>

--create hibernate.cfg.xml file
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC 
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>

        <!-- Database connection settings -->
<!--    <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>         can be also used as connection.driver_class-->        
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql//localhost:3306/sbms</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">admin@123</property>

        <!-- JDBC connection pool (built-in) -->
        <property name="hibernate.connection.pool_size">10</property>

        <!-- SQL dialect -->
        <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>

        <!-- Show SQL in console -->
        <property name="hibernate.show_sql">true</property>

        <!-- Automatically create/update table -->
        <property name="hibernate.hbm2ddl.auto">update</property>   //initially can keep it as create

        <!-- Mapping file -->
        <mapping resource="Student.hbm.xml"/>

    </session-factory>
</hibernate-configuration>

-Add StudentDao interface

public interface StudentDao {
	void saveStudent(Student student);
	Student loadStudent(int sid);
	Student updateStudentMarks(int sid, int marks);
	void deleteStudent(int sid);
}

--Create implementation class

mm 
public class StudentDaoImpl implements StudentDao {

	// Declare a SessionFactory (heavyweight object - shared across the application)
	private SessionFactory factory;

	// Constructor: Initializes Hibernate and builds the SessionFactory
	public StudentDaoImpl() {
		// Step 1: Create a ServiceRegistry — reads hibernate.cfg.xml and applies
		// configuration
		ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure("hibernate.cfg.xml") // make
																												// sure
																												// the
																												// file
																												// name
																												// is
																												// correct
				.build();

		// Step 2: Create Metadata from the service registry (contains mappings and
		// configuration)
		Metadata metadata = new MetadataSources(serviceRegistry).getMetadataBuilder().build();

		// Step 3: Build the SessionFactory from metadata (used to open sessions)
		factory = metadata.getSessionFactoryBuilder().build();
	}

	@Override
	public void saveStudent(Student student) {
		// Step 4: Open a new Session (lightweight object, not thread-safe)
		Session session = factory.openSession();

		// Step 5: Begin a transaction (required for INSERT/UPDATE/DELETE)
		Transaction t = session.beginTransaction();

		try {
			// Step 6: Save the Student entity to the database
			session.save(student);
			// OR, in Hibernate 6+, you can use: session.persist(student);

			System.out.println("✅ Student object is persisted in the database.");

			// Step 7: Commit the transaction — finalizes the changes in DB
			t.commit();

		} catch (Exception e) {
			// Step 8: If any issue occurs, rollback the transaction to maintain DB
			// integrity
			t.rollback();
			System.out.println("❌ Issue occurred while persisting Student object.");
			e.printStackTrace();
		} finally {
			// Step 9: Close the Session to release JDBC and Hibernate resources
			session.close();

			// Note: Do not close factory here; it should live for the entire app lifecycle.
		}
	}

	@Override
	public Student loadStudent(int sid) {
		// TODO Auto-generated method stub
		/*
		 * load():lazy loading get():early loading args: 1) Classname.class 2) id
		 * value(primary key value)
		 */
		Session session = factory.openSession();
		// Student student = session.get(Student.class, sid); //for early loading-->we
		// can see Select Query in the console
		Student student = session.load(Student.class, sid); // for lazy loading
		try {
			Thread.sleep(30000);
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Name of the Student: " + student.getSname());
		session.close(); // Exception while lazy loading so comment it, use only when early loading or
							// add delay to execution
		return student;
	}

	@Override
	public Student updateStudentMarks(int sid, int marks) {
		// TODO Auto-generated method stub
		Session session = factory.openSession();
		Student student = session.get(Student.class, sid);
		Transaction t = session.beginTransaction();
		try {
			student.setMarks(marks);
			session.update(student);
			t.commit();
			System.out.println("Record is Updated :)");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			t.rollback();
			System.out.println("Record is not Updated :(");
		} finally {
			session.close();
		}
		return student;
	}

	@Override
	public void deleteStudent(int sid) {
		// TODO Auto-generated method stub
		Session session = factory.openSession();
		Student student = session.get(Student.class, sid);
		Transaction t = session.beginTransaction();
		try {
			session.delete(student);
			t.commit();
			System.out.println("Record Deleted Successfully: ");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			t.rollback();
			System.out.println("Record Deletion Failed");
		}finally {
			session.close();
		}

	}
}


--Create client
public class ClientApp {
	public static void main(String[] args) {
		StudentDao dao = new StudentDaoImpl();
		
		/*
		 * Student student = new Student(); 
		 * student.setSid(101);
		 * student.setSname("ROHIT"); 
		 * student.setGender("Male"); 
		 * student.setMarks(600);
		 * 
		 * dao.saveStudent(student);
		 */
		/*Student student = dao.loadStudent(1);*/
		Student student = dao.updateStudentMarks(1, 720);
		System.out.println(student);
		
		dao.deleteStudent(2);
	}

}

Output: 
 Hibernate: drop table if exists STUDENT
Nov 02, 2025 9:44:31 PM org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection
INFO: HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@563ccd31] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.
Hibernate: create table STUDENT (MARKS integer, SID integer not null, GENDER varchar(255), SNAME varchar(255), primary key (SID)) engine=InnoDB
Nov 02, 2025 9:44:31 PM org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection
INFO: HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@33ec2c0c] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.
Hibernate: select max(SID) from STUDENT
✅ Student object is persisted in the database.
Hibernate: insert into STUDENT (GENDER,MARKS,SNAME,SID) values (?,?,?,?)

--hibernate.hbm2ddl.auto
------------------------
create-->Hibernate drops the existing tables, creates new tables in DB to perform operations
update-->Hibernate uses existing tables to perform operations
create-drop--->Hibernate creates new tables to perform operations and drops the table at the end of the application. Mostly used in Unit testing
validate(default)--->Hibernate validates the tables and columns in the db. If a table/a column doesn't exists, it will throw an Exception. This is the default value of property
Note: For mysql, initially with update also can create table

Lazy Loading:-->
-------------
@Override
	public Student loadStudent(int sid) {
		Session session = factory.openSession();
		//Student student = session.get(Student.class, sid);      //for early loading-->we can see Select Query in the console
		Student student = session.load(Student.class, sid);   //for lazy loading
		try {
			Thread.sleep(30000);
		 }catch(Exception e) {
			 e.printStackTrace();
		 }
		System.out.println("Name of the Student: "+student.getSname());
		session.close();          //Exception while lazy loading so comment it, use only when early loading or add delay to execution
		return student;
	}
Note: while lazy loading/early loading second parameter is primary key
output:
Hibernate: select s1_0.SID,s1_0.GENDER,s1_0.MARKS,s1_0.SNAME from STUDENT s1_0 where s1_0.SID=?
Name of the Student: ROHIT
Student [sid=1, sname=ROHIT, gender=Male, marks=600]
	
-->If sid doesn't exists---> get()-->throws NullPointerException
                             load()--->throws ObjectNotFoundException
							 
--If table does not have primary key, can we able to map java class with table---> No issue in mapping, but we will get issue in retrieval

--Caching--->
---------
Level 1 cache(Session-Level/L1 Cache/Local Cache): -->We can't enable or disable this cache, its by default
--------------
-Whenever session object created by default in hibernate, buffer(i.e cache memory) allocated for Object i.e Level 1 cache(1 MB)
    Session session = factory.openSession();
	Student student = session.get(Student.class, sid);  //when it calls get(), first hibernate check if object exists in cache, if not go to db and load object and store 1st into cache
    Session other_session = factory.openSession();     
    Student stu = other_session.get(Student.class, sid);  //Here we get it from cache	
	
-One session's cache cannot be used by other session i.e every session maintains own cache.(i.e Every session object has its own cache)
-Whenever a session object is created, automatically its cache created. when session closed cache is also closed
-We don't have any properties to enable/disable this Level1 cache.
           Student student = session.get(Student.class, 101);
		   Student student = session.get(Student.class, 102);
		   Student student = session.get(Student.class, 101);
    In above code, hibernate hits db 2 times-->we can see select query 2 times
Requirement-->To remove 101 from cache i.e Delete particular object from cache
   we can do it using evict() method---->session.evict();
           -->To remove all the objects from cache from cache at a time
   we can do it using clear() method---->session.clear();
Note: close() --->Removes Cache
    l clear() --->Removes object from cache
	
	
	@Override
	public void levelOneCacheTest() {     //add in daoimpl
		// TODO Auto-generated method stub
		System.out.println("--Check the console for number of queries");
		Session session = factory.openSession();
		Student s1 = session.get(Student.class, 1);
		Student s2 = session.get(Student.class, 2);
		Student s3 = session.get(Student.class, 1);
		
		Session other_session = factory.openSession();
		Student s4 = other_session.get(Student.class, 1);
	}
	
	
--Drawback of the cache
-----------------------
-If any changes are made to the object in DB, they are not reflected in cache automatically
Solution--> You have to explicitly refresh the cache for every same time interval to make the object in cache are in sync with database
-DAO classes are tightly coupled with ORM framework(ex-hibernate). we will make it loosely coupled, so that we can move to other ORM tool easily.
This can be done with JPA specifications. we will use JPA annotations to define mapping
Note:--> Annotations are like interface(i.e special interface--->use @Interface)
         For annotations, parser class(like implementation class for interface) provided by framework
		 
--JPA Annotations for Mapping:-->javax.persistence package of JPA
-----------------------------
Class Level annotations
-@Entity-->It will declare that POJO class is Entity class
-@Table--> It is used to map a Java Class/POJO class with a table in the Database(This annotation is optional)
Field Level annotations
-@Id-->It is used to map a variable in our java class with a primary key column in a table
-@Column-->It is used to map a variable with a column in the table(This annotation is optional)
Note: If we are using remote db, the we have to implement Serializable inteface

@Entity
@Table(name="TBL_STUDENT")
public class Student implements Serializable{
    @Id
	@column(name = "SID")
	private Integer sid;
	@column(name = "SNAME")
	private String sname;
	@column(name = "GENDER")
	private String gender;
	@column(name = "MARKS")
	private Integer marks;
	@Transient
	private String result;
	//setters and getters
}
Note:--> Using @Transient for variable which does not have a corresponding column in the table
     -->We can map Java class with table having more columns when extra columns of the table does not contain NOT NULL constraint
	 --While working with JPA and Hibernate, we have to create 'persistence.xml' file(under META-INF directory inside src/main/resources) instead of hibernate configuration file

persistence.xml
--------------- 
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
                                 http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
             version="2.1">

    <!-- Persistence Unit -->
    <persistence-unit name="studentPU" transaction-type="RESOURCE_LOCAL">

        <!-- Hibernate as Provider -->
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>

        <!-- Entity Class -->
        <class>com.alchemist.entity.Student</class>

        <!-- Connection Properties -->
        <properties>
            <property name="javax.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/>
            <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/testdb"/>
            <property name="javax.persistence.jdbc.user" value="root"/>
            <property name="javax.persistence.jdbc.password" value="root"/>

            <!-- Hibernate Settings -->
            <property name="hibernate.dialect" value="org.hibernate.dialect.MySQLDialect"/>
            <property name="hibernate.hbm2ddl.auto" value="update"/>
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>

            <!-- Optional: Connection Pool -->
            <property name="hibernate.connection.pool_size" value="10"/>
        </properties>
    </persistence-unit>
</persistence>


Note: Like SessionFactory, their is EntityManagerFactory in JPA
      JPA has package---> javax.persistence.EntityManagerFactory
	                      javax.persistence.EntityManager
						  javax.persistence.EntityTransaction
						  javax.persistence.Persistence
	  These are the mostly used packages
	  
JpaHibernateApplication
-----------------------
--You don’t strictly need JAXB in modern Hibernate (6.x) + JPA setups.In older Hibernate versions (≤ 5.3), hibernate.cfg.xml and *.hbm.xml files used JAXB (Java Architecture for XML Binding) 
to parse XML configuration and mapping files.

<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.1</version>
</dependency>
<dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
    <version>2.3.1</version>
</dependency>

--Modern Hibernate (6.x)-->Starting with Hibernate 6.x, JAXB is no longer required for annotation-based (JPA) mappings.
✅ You don’t need JAXB if:
You are using @Entity, @Table, @Column annotations (JPA annotations)
You configure Hibernate via persistence.xml
You don’t use .hbm.xml mapping files
--In Hibernate 6, EntityManager API is already included inside hibernate-core.

<dependencies>
		<!-- JPA Dependencies -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-entitymanager</artifactId>
			<version>5.2.17.Final</version>
		</dependency>
		<dependency>
			<groupId>org.hibernate.javax.persistence</groupId>
			<artifactId>hibernate-jpa-2.1-api</artifactId>
			<version>1.0.2.Final</version>
		</dependency>
		<!-- Hibernate Dependency -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>5.3.1.Final</version>
		</dependency>
		<!-- MySQL Driver Dependency -->
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>8.0.31</version>
		</dependency>
		<!-- JAXB Dependencies -->
		<dependency>
			<groupId>javax.xml.bind</groupId>
			<artifactId>jaxb-api</artifactId>
			<version>2.3.1</version>
		</dependency>
		<dependency>
			<groupId>com.sun.xml.bind</groupId>
			<artifactId>jaxb-core</artifactId>
			<version>2.3.0.1</version>
		</dependency>
		<dependency>
			<groupId>com.sun.xml.bind</groupId>
			<artifactId>jaxb-impl</artifactId>
			<version>2.3.1</version>
		</dependency>
	</dependencies>

Note: Remove These (Not Needed)
❌ hibernate-entitymanager → Already included in hibernate-core since 5.2+.
❌ hibernate-jpa-2.1-api → Use javax.persistence-api:2.2 instead.
(It’s newer and matches Hibernate 5.3.1).
❌ com.sun.xml.bind:jaxb-core & jaxb-impl — You can safely replace them with a single jaxb-runtime dependency (cleaner and modern).

--create src/main/resources-->then Update project, and then crate META-INF folder inside it, again Update project
--Inside META-INF-->create persistence.xml

<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
                                 http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
             version="2.1">

    <!-- Persistence Unit -->
    <persistence-unit name="products" transaction-type="RESOURCE_LOCAL">
    <!--transaction-type="JTA", when multiple dbs-->

        <!-- Hibernate as Provider -->
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>

        <!-- Entity Class -->
        <class>com.alchemist.entity.ProductEntity</class>

        <!-- Connection Properties -->
        <properties>
            <property name="javax.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/>
            <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/sbms"/>
            <property name="javax.persistence.jdbc.user" value="root"/>
            <property name="javax.persistence.jdbc.password" value="admin@123"/>

            <!-- Hibernate Settings -->
            <property name="hibernate.dialect" value="org.hibernate.dialect.MySQL8Dialect"/>   //change dialect to latest
            <property name="hibernate.hbm2ddl.auto" value="update"/>
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.dialect.storage_engine" value="innodb"/>    //to avoid error


            <!-- Optional: Connection Pool -->
            <property name="hibernate.connection.pool_size" value="10"/>
        </properties>
    </persistence-unit>
</persistence>



@Entity
@Table(name = "PRODUCT_TBL")
public class ProductEntity {
	@Id
	@Column(name = "product_id")
	private Integer productId;
	@Column(name = "product_name")
	private String productName;
	private Integer quantity;
	@Column(name = "unit_price")
	private Double unitPrice;
	@CreationTimestamp
	@Column(name = "created_on")
	private LocalDate createdOn;
	@UpdateTimestamp
	@Column(name = "update_on")
	private LocalDate updatedOn;
	//getters and setters
}

public interface ProductDao {
	ProductEntity saveProduct(ProductEntity product);
	ProductEntity loadProductById(Integer productId);
	ProductEntity updateProductById(Integer productId,Double new_unitPrice);
	void deleteProductById(Integer productId);
	public void closeFactory();
}

public class ProductDaoImpl implements ProductDao {

	private EntityManagerFactory factory;
	
	public ProductDaoImpl() {
		factory = Persistence.createEntityManagerFactory("products");
	}

	@Override
	public ProductEntity saveProduct(ProductEntity product) {
		EntityManager entityManager = factory.createEntityManager();
		EntityTransaction tx = entityManager.getTransaction();
		tx.begin();
		try {
			entityManager.persist(product);
			tx.commit();
			System.out.println("Product is inserted in DB");
		} catch (Exception e) {
			tx.rollback();
			System.out.println("Error in inserting a product in db...." + e);
		} finally {
			entityManager.close();
		}
		return product;
	}

	@Override
	public ProductEntity loadProductById(Integer productId) {
		EntityManager entityManager = factory.createEntityManager();
		/*
		 * find(): Early load getReference(): Lazy Load
		 */
		ProductEntity product = entityManager.find(ProductEntity.class, productId);
		entityManager.close();
		return product;
	}

	@Override
	public ProductEntity updateProductById(Integer productId, Double new_unitPrice) {
		EntityManager entityManager = factory.createEntityManager();
		ProductEntity product = entityManager.find(ProductEntity.class, productId);
		if (product == null) {
			System.out.println("Product ID not found: " + productId);
			return null;
		}
		EntityTransaction tx = entityManager.getTransaction();
		tx.begin();
		product.setUnitPrice(new_unitPrice);
		tx.commit();
		entityManager.close();
		return product;
	}

	@Override
	public void deleteProductById(Integer productId) {
		EntityManager entityManager = factory.createEntityManager();
		ProductEntity product = entityManager.find(ProductEntity.class, productId);
		if (product == null) {
			System.out.println("Product ID not found: " + productId);
			return;
		}
		EntityTransaction tx = entityManager.getTransaction();
		tx.begin();
		entityManager.remove(product);
		tx.commit();
		entityManager.close();
		System.out.println("🗑️ Deleted product: " + productId);
	}
	
	public void closeFactory() {
	    if (factory != null && factory.isOpen()) {
	        factory.close();
	        System.out.println("EntityManagerFactory closed successfully.");
	    } else {
	        System.out.println("EntityManagerFactory already closed or null.");
	    }
	}


}


public class ClientApp {
    public static void main(String[] args) {
        ProductDao dao = new ProductDaoImpl();
        
     // 🔹 Register shutdown hook at application start
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            dao.closeFactory();
            System.out.println("Hibernate closed on JVM shutdown.");
        }));
		
		/*
		 * ProductEntity entity = new ProductEntity(); 
		 * entity.setProductId(4);
		 * entity.setProductName("Graphic Cards"); 
		 * entity.setQuantity(3);
		 * entity.setUnitPrice(15000.00);
		 * 
		 * dao.saveProduct(entity);
		 */
		 
        
        //dao.updateProductById(1, 60000.00);
        ProductEntity product = dao.loadProductById(2);
        System.out.println(product);
        dao.deleteProductById(4);
    }
}



