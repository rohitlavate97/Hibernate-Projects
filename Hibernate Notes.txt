Hibernate:--> JDBC knowledge + SQL Understanding
Data Persistence:-->Storing data permanently, it has 3 components
-Data--> Represents what to persist
   Raw data
   Java Object
-Medium-->How to persist
   Java I/O Streams
   Serialization/DeSerialization
   JDBC(Java Database Connectivity)
-Storage-->Where to persists
   File
   Database
Note: Flat file->Not related to any technology ex-TXT file
+-------------+        +-------------------+        +-------------+
|   Raw Data  | <----> |   Java I/O Streams| <----> |   Flat File |
+-------------+        +-------------------+        +-------------+

                        (acts as Data Medium)
---------------------------------------------------------------

+--------------+   <-->   +---------------------------+   <-->   +-------------+
|  Java Object |   <-->   | Serialization /           |   <-->   |   Flat File |
|              |           | Deserialization Process   |          |             |
+--------------+           +---------------------------+          +-------------+

-Serialization-->It is a process of converting Java Object into stream of bytes
Note: This Stream of bytes can be stored into a file or can be transferred over a network.(Only serialized object can be sent over the network)
-DeSerialization-->It is the process of converting a streams of bytes into Java Object

Drawback of Using a file as a data storage:-->
-Data Redundancy(Duplication of data)
-Data inconsistency(Data stored in 2 file, modified in 1 file)
-Data Security(May be visible when file open)
-Storage
-No Transaction Support
-No Constraints Support

JDBC(Java DataBase Connectivity)
--------------------------------
+-------------------------+     <----->     +-------------------------+     <----->     +-------------------------+
|  Raw Data / Java Object |                 |          JDBC           |                 |        Database         |
|                         |                 | (Java Database API)     |                 | (MySQL / Oracle / etc.) |
+-------------------------+                 +-------------------------+                 +-------------------------+

CRUD Operations-->Create(Inserting data),Read(Selecting),Update(Modifying),Delete(Removing)

Requirement:-->We have an employee object, which we want to store into data base using JDBC API
    Process:-->Read the data from Employee object by calling Getter method
	           Create a PreparedStatement object of JDBC
			   Now set the data to PreparedStatement and execute it
Note: In Realtime,data is in object, and JDBC is suitable for raw data. JDBC don't have save() or persist() methods. It has executeUpdate()/executeQuery()

Why we need ORM tool?--> Need to transfer Java objects between our app and a db
--------------------
---JDBC
-Saving data(Insert operations)
Employee Object
+-------+-----+------+
| 102   | B   | 6000 |
+-------+-----+------+
       |
       | 1. Call getConnection()
       | 2. PrepareStatement()
       | 3. Set the data
       | 4. Execute it
       v
+-----------------------------+
| Database Table: EMPLOYEE    |
+-------+-----+------+
| 101   | A   | 4000 |
| 102   | B   | 6000 |
+-------+-----+------+

-Retrieving data(select operations)
Technology: JDBC

Steps:
1. Execute query
2. getXXX() (ResultSet methods)
3. Create Employee object
4. Set the data

+-----------------------------+
| Database Table: EMPLOYEE    |
+-------+-----+------+
| 101   | A   | 4000 |
| 102   | B   | 6000 |
+-------+-----+------+
       |
       v
ResultSet
+-------+-----+------+
| 101   | A   | 6000 |
+-------+-----+------+
       |
       v
Employee Object
+-------+-----+------+
| 101   | A   | 6000 |
+-------+-----+------+

---ORM
-Saving Data
Employee Object
+-------+-----+------+
| 102   | B   | 6000 |
+-------+-----+------+
       |
       | save()
       v
+-----------------------------+
| Database Table: EMPLOYEE    |
+-------+-----+------+
| 101   | A   | 4000 |
| 102   | B   | 6000 |
+-------+-----+------+

-Retrieving data
+-----------------------------+
| Database Table: EMPLOYEE    |
+-------+-----+------+
| 101   | A   | 4000 |
| 102   | B   | 6000 |
+-------+-----+------+
       |
       | load()
       v
Employee Object
+-------+-----+------+
| 102   | B   | 6000 |
+-------+-----+------+

--Hibernate(Open Source ORM framework from JBOSS Community)
---------------------------------------
-Transfer objects between our Java app and a database(Both SQL and NoSQL)
-Alternate tools-->TopLink, MyBatis,ORMLite,DataNucleus
-FrameWork provides a set of libraries for the common functionalities of a Java project. so it reduces coding efforts

JPA(Java Persistence API):-->Specification by Sun MicroSystem
-------------------------
Object Model and Relational model are different
To allow developers to switch easily from one ORM tool to another, common specifications provided by SUN Microsystem and ORM tool vendors provided implementation
Most of the JPA Specification is created by taking the features from Hibernate and some features from TopLink
-If we want to migrate form hibernate to MyBatis-->Just configure the Project Config file.

--Feature of Hibernate-->
1)HQL(Hibernate Query Language)-->It is the own query language of Hibernate
-----------------------------
-Hibernate has provided HQL to make the DAO classes as Database independent(SQL queries are database dependent)
-HQL doesn't provide any burden on developer because HQL queries are also looks like SQL queries only
-In SQL Queries, we use column names and table names, But in HQL Queries, we use variables names and class references
Ex:1) (SQL)-->select * from emp
      (HQL)-->select e from Employee e 
   2) (SQL)-->select empno,ename from emp
      (HQL)-->select e.employeeNo,e.employeeName from Employee e

2)Caching
---------
                    +-------------------+
                    | Java Application  |
                    +---------+---------+
                              |
                              v
                    +-------------------+
                    |     Hibernate     |
                    +---------+---------+
                              |
                              v
          +---------------------------------------+
          | Check: Object exists in L1 Cache?     |
          +---------------------------------------+
                       |                 |
                    (YES)              (NO)
                       |                 |
                       v                 v
        +-----------------------+   +-----------------------------------+
        | Return from L1 Cache  |   | Check: Object exists in L2 Cache? |
        +-----------------------+   +-----------------------------------+
                                          |                 |
                                       (YES)              (NO)
                                          |                 |
                                          v                 v
                             +------------------------+   +--------------------+
                             | Copy object to L1      |   |   Fetch from DB    |
                             | Return to Application  |   +--------------------+
                             +------------------------+            |
                                          |                        |
                                          |                        v
                                          |            +------------------------+
                                          |            | Copy object to L2 Cache|
                                          |            +------------------------+
                                          |                        |
                                          +------------<------------+
-Caching improves performance of an application by loading object from cache memory.
In hibernate, 2 levels of cache can be used-->Level 1, Level 2

3) Lazy loading--> By default, Servelet is lazy loaded. Instance varibles are lazy loaded, after object creation it will get memory.
---------------
-When a java app is asking for an object, the Hibernate will create a proxy object and return it to app without loading it from cache/db. when app is accessing the proxy object
then hibernate will laod the real object from db. By doing this hibernate will reduce round trips between app and db
                          ┌────────────────────────────┐
                          │        Application         │
                          │ (Java App accessing data)  │
                          └─────────────┬──────────────┘
                                        │
                    (1) Ask Hibernate for Employee object
                                        │
                                        ▼
                          ┌────────────────────────────┐
                          │         Hibernate          │
                          │ (ORM Framework handling DB)│
                          └─────────────┬──────────────┘
                                        │
                    (2) Creates a Proxy Object for Employee
                                        │
                                        ▼
                          ┌────────────────────────────┐
                          │        Proxy Object        │
                          │ (Placeholder for Employee) │
                          └─────────────┬──────────────┘
                                        │
                    (3) When App Accesses Data (getName, etc.)
                                        │
                                        ▼
                          ┌────────────────────────────┐
                          │         Database           │
                          │ (Fetches Real Employee Data)│
                          └─────────────┬──────────────┘
                                        │
                    (4) Returns Actual Data to Hibernate
                                        │
                                        ▼
                          ┌────────────────────────────┐
                          │        Application         │
                          │ (Now holds Real Object)    │
                          └────────────────────────────┘

4) Connection Pooling--> To get connection with DB--->DriverManager class--->Physical connection, DataSource interface-->Connection pool
---------------------
-Connection pool-->Memory area, buffer,temporary memory where db connections stored(Ready made connections)
-Hibernate has a built-in connection poolling mechanism, where it creates a pool when app is started, maintain it and destroys the pool when app shutdown
┌────────────────────────────┐
│        Java App            │
│  (JDBC / Hibernate / JPA)  │
└─────────────┬──────────────┘
              │
   (1) Request a DB connection
              │
              ▼
┌────────────────────────────┐
│        DataSource          │
│ (Configured in app)        │
│ Acts as bridge to the pool │
└─────────────┬──────────────┘
              │
   (2) Fetch available connection
              │
              ▼
┌────────────────────────────┐
│     Connection Pool        │
│ (HikariCP, C3P0, etc.)     │
│ Pre-created connections:   │
│ [Conn1] [Conn2] [Conn3]... │
└─────────────┬──────────────┘
              │
   (3) Provide one connection
              │
              ▼
┌────────────────────────────┐
│         Database            │
│ Executes SQL queries, etc.  │
└─────────────┬──────────────┘
              │
   (4) Return results to App
              │
              ▼
┌────────────────────────────┐
│        Java App            │
│ Processes results           │
│ and closes connection       │
└─────────────┬──────────────┘
              │
   (5) Connection is **not destroyed** —
       it’s **returned to the pool**
       for **reuse** by next request
              │
              ▼
┌────────────────────────────┐
│     Connection Pool        │
│ Conn1 is now free again    │
└────────────────────────────┘


               ┌────────────────────────────┐
               │      Application Start      │
               └──────────────┬──────────────┘
                              │
                     (1) Hibernate Initialized
                              │
                              ▼
               ┌────────────────────────────┐
               │  Hibernate Connection Pool │
               │   (Built-in Mechanism)     │
               ├────────────────────────────┤
               │ Creates pool of connections│
               │ e.g., [Conn1][Conn2][Conn3]│
               │ Maintains them for reuse   │
               └──────────────┬──────────────┘
                              │
                   (2) Hibernate Sessions use
                        connections from pool
                              │
                              ▼
               ┌────────────────────────────┐
               │         Database            │
               │  (SQL executed via JDBC)    │
               └──────────────┬──────────────┘
                              │
                   (3) When work completes,
                       connection returned to pool
                              │
                              ▼
               ┌────────────────────────────┐
               │  Hibernate Connection Pool │
               │ Connection now reusable    │
               └──────────────┬──────────────┘
                              │
                 (4) Application Shutdown
                              │
                              ▼
               ┌────────────────────────────┐
               │   Pool destroyed, all DB    │
               │   connections closed safely │
               └────────────────────────────┘
5) Criteria---> To get same data from database, we can write different queries. but, a query which returns the data fastly is important.
-----------
-Example--> Query1-->select * from emp;
            Query2-->select empno,ename,sal,deptno from emp; (This is faster)
-In Hibernate, Criteria API is provided to create tuned queries. So an app will fetch data fastly from DB, and hence the performance is improved.

6) Locking--->When two transactions concurrently working on same data, then one transactions made changes should not be overridden by another transactions
----------
-Transaction operations-->Insert, Update and Delete
-By default, multiple transactions can work on the same data concurrently. so it is possible that changes made by one transaction can be overridden by the another transaction
-To prevent it, hibernate has provided locking
-Types of Locking on multiple transactions working on the same data
   Optimistic Locking
   Pessimistic Locking
  
7) Associations: Hibernate Support Associations/relationships
----------------
-OneToMany
-ManyToOne
-ManyToMany
-OneToOne

--Files required for first application
---------------------------------------
-POJO class (Plain Old Java Object)--->class not extending any class or implementing any interface from any API(Hibernate,Struts etc) except java.io.Serializable interface
-----------
example:
        Class A{         ------>POJO Class
		   //variables
		   //methods
		}
		
		Class B extends A{ ------>If base is POJO class then, derived class is also POJO class
		   //variables
		   //methods
		}
Note: Every Java Bean is Pojo Class, but every POJO Class is not a Java Bean class
Note: Java Bean--->Follows below rules
                   -Class must be public
				   -Class must contain default constructor/paramet-less constructor/paramet-less
				   -private memeber should contain setter/getter methods
				   -Class can implement Serializable interface
-Mapping file ---> It is used to map a Java Class with a database table and Java Class variable with table columns
-------------
                   Mapping can be done in 2 ways
                    -XML file(____.hbm.xml)	
                    -annotations(JPA)		
   exmaple:-->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping> 
    <!-- Mapping Java class to table -->
    <class name="com.alchemist.model.Employee" table="employee">
        
        <!-- Primary Key Mapping -->
        <id name="id" column="emp_id">
            <generator class="increment"/>
        </id>
        
        <!-- Other Properties -->
        <property name="name" column="emp_name" type="string"/>
        <property name="department" column="department" type="string"/>  ----->column attribute is optional when property name and column name matching
        <property name="salary" column="salary" type="double"/>
        <property name="joiningDate" column="joining_date" type="date"/>

    </class>
</hibernate-mapping>

					
-Configuration File---> based on number of db's in application
-------------------
-configuraion file is for configuring below things
       -Connection properties
	   -Hibernate properties
	   -Mapping files
	
	Exmaple-->hibernate.cfg.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC 
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
    "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

<hibernate-configuration>

    <session-factory>

        <!-- Database Connection Settings -->
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/employee_db</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">root</property>

        <!-- JDBC Connection Pooling (Hibernate built-in) -->
        <property name="hibernate.connection.pool_size">10</property>

        <!-- SQL Dialect -->
        <property name="hibernate.dialect">org.hibernate.dialect.MySQL8Dialect</property>   --->//Prepare SQL Query to run ob db

        <!-- Optional Settings -->
        <property name="hibernate.show_sql">true</property>        ---->//to log queries
        <property name="hibernate.format_sql">true</property>
        <property name="hibernate.hbm2ddl.auto">update</property>  ----->//to create table if not exists

        <!-- Caching (optional) -->
        <property name="hibernate.cache.use_second_level_cache">false</property>

        <!-- Mapping File -->
        <mapping resource="com/alchemist/model/Employee.hbm.xml"/>   ----->their can be multiple mapping files(1db=1 configuraion file)

    </session-factory>

</hibernate-configuration>

	
--Client Program
---------------
-In SessionFactory object entire configuration metadata will be loaded. Application can't perform CRUD directly using SessionFactory object, Session object(with it hibernate performs operation on db) also created.
-When login with credentials-->One session created in server. when logout-->session closed(session object store information of activity done). Without logout if we close browser,
session is still active, but if we not accessed it for configured time--->server will invalidate session(Session Management)
-SessionFactory creates Session objects depends upon number of requests(5 requests by 5 users-->5 sessions)
--Steps to write the client progream
      -Create a SessionFactory(interface) object
	  -Create a Session object
	  -Create a Transaction object
	  -Perform CRUD operations
	  -Commit/Rollback the Transaction
	  -Close the Session
	  -Close the SessionFactory(No need in real-time application)
Note:-High level object in Hibernate is SessionFactory object, which holds the configuration metadata
     -SessionFactory object is factory for creating Session object
	 -When Session is created, a connection with db is established
	 -A Session object is the main runtime object to perform DB Operations
	 -In Realtime applications, a Session object is created for each request.
	 -A Session object can be used to create a Transaction object.
	 -In Hibernate, Transaction is mandatory to perform insert/update/delete operations. For Select operations, it is optional
	 -End the Transaction with commit/rollback
	 -If no more operations are required, then close the Session
	 -If no more Sessions are required, then close the SessionFactory object

                   ┌────────────────────────────┐
                   │      Application Code       │
                   └─────────────┬───────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 1️⃣ Create SessionFactory (Heavy Object)    │
          │ Reads hibernate.cfg.xml, builds connection  │
          │ pool, metadata, and ORM mapping.            │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 2️⃣ Open Session                            │
          │ Represents a single unit of work with DB.   │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 3️⃣ Begin Transaction                       │
          │ Ensures atomic operation (commit/rollback). │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 4️⃣ Perform CRUD Operations                 │
          │ - session.save()   → Insert                 │
          │ - session.get()    → Read                   │
          │ - session.update() → Update                 │
          │ - session.delete() → Delete                 │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 5️⃣ Commit or Rollback Transaction           │
          │ tx.commit() or tx.rollback()                │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 6️⃣ Close Session                           │
          │ Frees JDBC connection, clears cache.        │
          └────────────────────────────────────────────┘
                                 │
                                 ▼
          ┌────────────────────────────────────────────┐
          │ 7️⃣ Close SessionFactory (Optional)         │
          │ Destroys connection pool on app shutdown.   │
          └────────────────────────────────────────────┘
Note: Maven is build tool, it will automate the build process of a Java application. Build process means creating the project structure, adding the jars to projectt classpath, compiling the source code,
      compiling and executing the test cases, packaging the project to jar/war file etc 
	  Archetypes:
	       For Simple Java Project: maven-archetype-quickstart
		   For Web app project: maven-archetypr-webapp
	  Maven Project Co-Ordinates:
	       groupId: a unique id to identify a group of projects of a client
		   artifactId: Project Name
		   version: Project version
	  Pom.xml-->To configure dependency-->Maven will download jars from maven central repo and strore them into local repository(C:/User/Admin/.m2)
	  src/main/java -->source code files
	  src/test/java -->test code files
	  src/main/resources -->for other resources/file(XML/properties/txt)
	  
-First Hibernate Project-->
------------------------
-Create Maven project with maven-archetype-quickstart 
GroupId-->com.alchemist
ArtifactId--> HibernateFirstApp

In pom.xml
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
  </properties>
  
-Add following dependencies
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>6.4.4.Final</version>
</dependency>

<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.4.0</version>
</dependency>

--Create Entity class
public class Student {
	private Integer sid;
	private String sname;
	private String gender;
	private Integer marks;
	//Generate getters and Setters
}

--Create Hibernate mappping file--->student.hbm.xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">

<hibernate-mapping>
    <class name="com.alchemist.entity.Student" table="STUDENT">

        <id name="sid" column="SID">
            <generator class="increment"/>
        </id>

        <property name="sname" column="SNAME"/>
        <property name="gender" column="GENDER"/>
        <property name="marks" column="MARKS"/>

    </class>
</hibernate-mapping>

--create hibernate.cfg.xml file
<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC 
    "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
    <session-factory>

        <!-- Database connection settings -->
<!--    <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>         can be also used as connection.driver_class-->        
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql//localhost:3306/sbms</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">admin@123</property>

        <!-- JDBC connection pool (built-in) -->
        <property name="hibernate.connection.pool_size">10</property>

        <!-- SQL dialect -->
        <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>

        <!-- Show SQL in console -->
        <property name="hibernate.show_sql">true</property>

        <!-- Automatically create/update table -->
        <property name="hibernate.hbm2ddl.auto">update</property>   //initially can keep it as create

        <!-- Mapping file -->
        <mapping resource="Student.hbm.xml"/>

    </session-factory>
</hibernate-configuration>

-Add StudentDao interface

public interface StudentDao {
	void saveStudent(Student student);
	Student loadStudent(int sid);
	Student updateStudentMarks(int sid, int marks);
	void deleteStudent(int sid);
}

--Create implementation class

mm 
public class StudentDaoImpl implements StudentDao {

	// Declare a SessionFactory (heavyweight object - shared across the application)
	private SessionFactory factory;

	// Constructor: Initializes Hibernate and builds the SessionFactory
	public StudentDaoImpl() {
		// Step 1: Create a ServiceRegistry — reads hibernate.cfg.xml and applies
		// configuration
		ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().configure("hibernate.cfg.xml") // make
																												// sure
																												// the
																												// file
																												// name
																												// is
																												// correct
				.build();

		// Step 2: Create Metadata from the service registry (contains mappings and
		// configuration)
		Metadata metadata = new MetadataSources(serviceRegistry).getMetadataBuilder().build();

		// Step 3: Build the SessionFactory from metadata (used to open sessions)
		factory = metadata.getSessionFactoryBuilder().build();
	}

	@Override
	public void saveStudent(Student student) {
		// Step 4: Open a new Session (lightweight object, not thread-safe)
		Session session = factory.openSession();

		// Step 5: Begin a transaction (required for INSERT/UPDATE/DELETE)
		Transaction t = session.beginTransaction();

		try {
			// Step 6: Save the Student entity to the database
			session.save(student);
			// OR, in Hibernate 6+, you can use: session.persist(student);

			System.out.println("✅ Student object is persisted in the database.");

			// Step 7: Commit the transaction — finalizes the changes in DB
			t.commit();

		} catch (Exception e) {
			// Step 8: If any issue occurs, rollback the transaction to maintain DB
			// integrity
			t.rollback();
			System.out.println("❌ Issue occurred while persisting Student object.");
			e.printStackTrace();
		} finally {
			// Step 9: Close the Session to release JDBC and Hibernate resources
			session.close();

			// Note: Do not close factory here; it should live for the entire app lifecycle.
		}
	}

	@Override
	public Student loadStudent(int sid) {
		// TODO Auto-generated method stub
		/*
		 * load():lazy loading get():early loading args: 1) Classname.class 2) id
		 * value(primary key value)
		 */
		Session session = factory.openSession();
		// Student student = session.get(Student.class, sid); //for early loading-->we
		// can see Select Query in the console
		Student student = session.load(Student.class, sid); // for lazy loading
		try {
			Thread.sleep(30000);
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("Name of the Student: " + student.getSname());
		session.close(); // Exception while lazy loading so comment it, use only when early loading or
							// add delay to execution
		return student;
	}

	@Override
	public Student updateStudentMarks(int sid, int marks) {
		// TODO Auto-generated method stub
		Session session = factory.openSession();
		Student student = session.get(Student.class, sid);
		Transaction t = session.beginTransaction();
		try {
			student.setMarks(marks);
			session.update(student);
			t.commit();
			System.out.println("Record is Updated :)");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			t.rollback();
			System.out.println("Record is not Updated :(");
		} finally {
			session.close();
		}
		return student;
	}

	@Override
	public void deleteStudent(int sid) {
		// TODO Auto-generated method stub
		Session session = factory.openSession();
		Student student = session.get(Student.class, sid);
		Transaction t = session.beginTransaction();
		try {
			session.delete(student);
			t.commit();
			System.out.println("Record Deleted Successfully: ");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			t.rollback();
			System.out.println("Record Deletion Failed");
		}finally {
			session.close();
		}

	}
}


--Create client
public class ClientApp {
	public static void main(String[] args) {
		StudentDao dao = new StudentDaoImpl();
		
		/*
		 * Student student = new Student(); 
		 * student.setSid(101);
		 * student.setSname("ROHIT"); 
		 * student.setGender("Male"); 
		 * student.setMarks(600);
		 * 
		 * dao.saveStudent(student);
		 */
		/*Student student = dao.loadStudent(1);*/
		Student student = dao.updateStudentMarks(1, 720);
		System.out.println(student);
		
		dao.deleteStudent(2);
	}

}

Output: 
 Hibernate: drop table if exists STUDENT
Nov 02, 2025 9:44:31 PM org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection
INFO: HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@563ccd31] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.
Hibernate: create table STUDENT (MARKS integer, SID integer not null, GENDER varchar(255), SNAME varchar(255), primary key (SID)) engine=InnoDB
Nov 02, 2025 9:44:31 PM org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection
INFO: HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@33ec2c0c] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.
Hibernate: select max(SID) from STUDENT
✅ Student object is persisted in the database.
Hibernate: insert into STUDENT (GENDER,MARKS,SNAME,SID) values (?,?,?,?)

--hibernate.hbm2ddl.auto
------------------------
create-->Hibernate drops the existing tables, creates new tables in DB to perform operations
update-->Hibernate uses existing tables to perform operations
create-drop--->Hibernate creates new tables to perform operations and drops the table at the end of the application. Mostly used in Unit testing
validate(default)--->Hibernate validates the tables and columns in the db. If a table/a column doesn't exists, it will throw an Exception. This is the default value of property
Note: For mysql, initially with update also can create table

Lazy Loading:-->
-------------
@Override
	public Student loadStudent(int sid) {
		Session session = factory.openSession();
		//Student student = session.get(Student.class, sid);      //for early loading-->we can see Select Query in the console
		Student student = session.load(Student.class, sid);   //for lazy loading
		try {
			Thread.sleep(30000);
		 }catch(Exception e) {
			 e.printStackTrace();
		 }
		System.out.println("Name of the Student: "+student.getSname());
		session.close();          //Exception while lazy loading so comment it, use only when early loading or add delay to execution
		return student;
	}
Note: while lazy loading/early loading second parameter is primary key
output:
Hibernate: select s1_0.SID,s1_0.GENDER,s1_0.MARKS,s1_0.SNAME from STUDENT s1_0 where s1_0.SID=?
Name of the Student: ROHIT
Student [sid=1, sname=ROHIT, gender=Male, marks=600]
	
-->If sid doesn't exists---> get()-->throws NullPointerException
                             load()--->throws ObjectNotFoundException
							 
--If table does not have primary key, can we able to map java class with table---> No issue in mapping, but we will get issue in retrieval

--Caching--->
---------
Level 1 cache(Session-Level/L1 Cache/Local Cache): -->We can't enable or disable this cache, its by default
--------------
-Whenever session object created by default in hibernate, buffer(i.e cache memory) allocated for Object i.e Level 1 cache(1 MB)
    Session session = factory.openSession();
	Student student = session.get(Student.class, sid);  //when it calls get(), first hibernate check if object exists in cache, if not go to db and load object and store 1st into cache
    Session other_session = factory.openSession();     
    Student stu = other_session.get(Student.class, sid);  //Here we get it from cache	
	
-One session's cache cannot be used by other session i.e every session maintains own cache.(i.e Every session object has its own cache)
-Whenever a session object is created, automatically its cache created. when session closed cache is also closed
-We don't have any properties to enable/disable this Level1 cache.
           Student student = session.get(Student.class, 101);
		   Student student = session.get(Student.class, 102);
		   Student student = session.get(Student.class, 101);
    In above code, hibernate hits db 2 times-->we can see select query 2 times
Requirement-->To remove 101 from cache i.e Delete particular object from cache
   we can do it using evict() method---->session.evict();
           -->To remove all the objects from cache from cache at a time
   we can do it using clear() method---->session.clear();
Note: close() --->Removes Cache
    l clear() --->Removes object from cache
	
	
	@Override
	public void levelOneCacheTest() {     //add in daoimpl
		// TODO Auto-generated method stub
		System.out.println("--Check the console for number of queries");
		Session session = factory.openSession();
		Student s1 = session.get(Student.class, 1);
		Student s2 = session.get(Student.class, 2);
		Student s3 = session.get(Student.class, 1);
		
		Session other_session = factory.openSession();
		Student s4 = other_session.get(Student.class, 1);
	}
	
	
--Drawback of the cache
-----------------------
-If any changes are made to the object in DB, they are not reflected in cache automatically
Solution--> You have to explicitly refresh the cache for every same time interval to make the object in cache are in sync with database
-DAO classes are tightly coupled with ORM framework(ex-hibernate). we will make it loosely coupled, so that we can move to other ORM tool easily.
This can be done with JPA specifications. we will use JPA annotations to define mapping
Note:--> Annotations are like interface(i.e special interface--->use @Interface)
         For annotations, parser class(like implementation class for interface) provided by framework
		 
--JPA Annotations for Mapping:-->javax.persistence package of JPA
-----------------------------
Class Level annotations
-@Entity-->It will declare that POJO class is Entity class
-@Table--> It is used to map a Java Class/POJO class with a table in the Database(This annotation is optional)
Field Level annotations
-@Id-->It is used to map a variable in our java class with a primary key column in a table
-@Column-->It is used to map a variable with a column in the table(This annotation is optional)
Note: If we are using remote db, the we have to implement Serializable inteface

@Entity
@Table(name="TBL_STUDENT")
public class Student implements Serializable{
    @Id
	@column(name = "SID")
	private Integer sid;
	@column(name = "SNAME")
	private String sname;
	@column(name = "GENDER")
	private String gender;
	@column(name = "MARKS")
	private Integer marks;
	@Transient
	private String result;
	//setters and getters
}
Note:--> Using @Transient for variable which does not have a corresponding column in the table
     -->We can map Java class with table having more columns when extra columns of the table does not contain NOT NULL constraint
	 --While working with JPA and Hibernate, we have to create 'persistence.xml' file(under META-INF directory inside src/main/resources) instead of hibernate configuration file

persistence.xml
--------------- 
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
                                 http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
             version="2.1">

    <!-- Persistence Unit -->
    <persistence-unit name="studentPU" transaction-type="RESOURCE_LOCAL">

        <!-- Hibernate as Provider -->
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>

        <!-- Entity Class -->
        <class>com.alchemist.entity.Student</class>

        <!-- Connection Properties -->
        <properties>
            <property name="javax.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/>
            <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/testdb"/>
            <property name="javax.persistence.jdbc.user" value="root"/>
            <property name="javax.persistence.jdbc.password" value="root"/>

            <!-- Hibernate Settings -->
            <property name="hibernate.dialect" value="org.hibernate.dialect.MySQLDialect"/>
            <property name="hibernate.hbm2ddl.auto" value="update"/>
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>

            <!-- Optional: Connection Pool -->
            <property name="hibernate.connection.pool_size" value="10"/>
        </properties>
    </persistence-unit>
</persistence>


Note: Like SessionFactory, their is EntityManagerFactory in JPA
      JPA has package---> javax.persistence.EntityManagerFactory
	                      javax.persistence.EntityManager
						  javax.persistence.EntityTransaction
						  javax.persistence.Persistence
	  These are the mostly used packages
	  
JpaHibernateApplication
-----------------------
--You don’t strictly need JAXB in modern Hibernate (6.x) + JPA setups.In older Hibernate versions (≤ 5.3), hibernate.cfg.xml and *.hbm.xml files used JAXB (Java Architecture for XML Binding) 
to parse XML configuration and mapping files.

<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.1</version>
</dependency>
<dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
    <version>2.3.1</version>
</dependency>

--Modern Hibernate (6.x)-->Starting with Hibernate 6.x, JAXB is no longer required for annotation-based (JPA) mappings.
✅ You don’t need JAXB if:
You are using @Entity, @Table, @Column annotations (JPA annotations)
You configure Hibernate via persistence.xml
You don’t use .hbm.xml mapping files
--In Hibernate 6, EntityManager API is already included inside hibernate-core.

	<dependencies>
		<!-- ✅ Hibernate Core (includes EntityManager from 5.2+) -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>5.3.1.Final</version>
		</dependency>

		<!-- ✅ JPA API -->
		<dependency>
			<groupId>javax.persistence</groupId>
			<artifactId>javax.persistence-api</artifactId>
			<version>2.2</version>
		</dependency>

		<!-- ✅ MySQL Driver -->
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>8.0.31</version>
		</dependency>

		<!-- ✅ JAXB (required if using Java 11+) -->
		<dependency>
			<groupId>javax.xml.bind</groupId>
			<artifactId>jaxb-api</artifactId>
			<version>2.3.1</version>
		</dependency>

		<dependency>
			<groupId>org.glassfish.jaxb</groupId>
			<artifactId>jaxb-runtime</artifactId>
			<version>2.3.1</version>
		</dependency>

		<!-- ✅ JUnit 5 -->
		<dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter-api</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter-params</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

Note: Remove These (Not Needed)
❌ hibernate-entitymanager → Already included in hibernate-core since 5.2+.
❌ hibernate-jpa-2.1-api → Use javax.persistence-api:2.2 instead.
(It’s newer and matches Hibernate 5.3.1).
❌ com.sun.xml.bind:jaxb-core & jaxb-impl — You can safely replace them with a single jaxb-runtime dependency (cleaner and modern).

--create src/main/resources-->then Update project, and then crate META-INF folder inside it, again Update project
--Inside META-INF-->create persistence.xml

<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
                                 http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
             version="2.1">

    <!-- Persistence Unit -->
    <persistence-unit name="products" transaction-type="RESOURCE_LOCAL">
    <!--transaction-type="JTA", when multiple dbs-->

        <!-- Hibernate as Provider -->
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>

        <!-- Entity Class -->
        <class>com.alchemist.entity.ProductEntity</class>

        <!-- Connection Properties -->
        <properties>
            <property name="javax.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/>
            <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/sbms"/>
            <property name="javax.persistence.jdbc.user" value="root"/>
            <property name="javax.persistence.jdbc.password" value="admin@123"/>

            <!-- Hibernate Settings -->
            <property name="hibernate.dialect" value="org.hibernate.dialect.MySQL8Dialect"/>   //change dialect to latest
            <property name="hibernate.hbm2ddl.auto" value="update"/>
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.dialect.storage_engine" value="innodb"/>    //to avoid error


            <!-- Optional: Connection Pool -->
            <property name="hibernate.connection.pool_size" value="10"/>
        </properties>
    </persistence-unit>
</persistence>



@Entity
@Table(name = "PRODUCT_TBL")
public class ProductEntity {
	@Id
	@Column(name = "product_id")
	private Integer productId;
	@Column(name = "product_name")
	private String productName;
	private Integer quantity;
	@Column(name = "unit_price")
	private Double unitPrice;
	@CreationTimestamp
	@Column(name = "created_on")
	private LocalDate createdOn;
	@UpdateTimestamp
	@Column(name = "update_on")
	private LocalDate updatedOn;
	//getters and setters
}

public interface ProductDao {
	ProductEntity saveProduct(ProductEntity product);
	ProductEntity loadProductById(Integer productId);
	ProductEntity updateProductById(Integer productId,Double new_unitPrice);
	void deleteProductById(Integer productId);
	public void closeFactory();
}

public class ProductDaoImpl implements ProductDao {

	private EntityManagerFactory factory;
	
	public ProductDaoImpl() {
		factory = Persistence.createEntityManagerFactory("products");
	}

	@Override
	public ProductEntity saveProduct(ProductEntity product) {
		EntityManager entityManager = factory.createEntityManager();
		EntityTransaction tx = entityManager.getTransaction();
		tx.begin();
		try {
			entityManager.persist(product);
			tx.commit();
			System.out.println("Product is inserted in DB");
		} catch (Exception e) {
			tx.rollback();
			System.out.println("Error in inserting a product in db...." + e);
		} finally {
			entityManager.close();
		}
		return product;
	}

	@Override
	public ProductEntity loadProductById(Integer productId) {
		EntityManager entityManager = factory.createEntityManager();
		/*
		 * find(): Early load getReference(): Lazy Load
		 */
		ProductEntity product = entityManager.find(ProductEntity.class, productId);
		entityManager.close();
		return product;
	}

	@Override
	public ProductEntity updateProductById(Integer productId, Double new_unitPrice) {
		EntityManager entityManager = factory.createEntityManager();
		ProductEntity product = entityManager.find(ProductEntity.class, productId);
		if (product == null) {
			System.out.println("Product ID not found: " + productId);
			return null;
		}
		EntityTransaction tx = entityManager.getTransaction();
		tx.begin();
		product.setUnitPrice(new_unitPrice);
		tx.commit();
		entityManager.close();
		return product;
	}

	@Override
	public void deleteProductById(Integer productId) {
		EntityManager entityManager = factory.createEntityManager();
		ProductEntity product = entityManager.find(ProductEntity.class, productId);
		if (product == null) {
			System.out.println("Product ID not found: " + productId);
			return;
		}
		EntityTransaction tx = entityManager.getTransaction();
		tx.begin();
		entityManager.remove(product);
		tx.commit();
		entityManager.close();
		System.out.println("🗑️ Deleted product: " + productId);
	}
	
	public void closeFactory() {
	    if (factory != null && factory.isOpen()) {
	        factory.close();
	        System.out.println("EntityManagerFactory closed successfully.");
	    } else {
	        System.out.println("EntityManagerFactory already closed or null.");
	    }
	}


}


public class ClientApp {
    public static void main(String[] args) {
        ProductDao dao = new ProductDaoImpl();
        
     // 🔹 Register shutdown hook at application start
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            dao.closeFactory();
            System.out.println("Hibernate closed on JVM shutdown.");
        }));
		
		/*
		 * ProductEntity entity = new ProductEntity(); 
		 * entity.setProductId(4);
		 * entity.setProductName("Graphic Cards"); 
		 * entity.setQuantity(3);
		 * entity.setUnitPrice(15000.00);
		 * 
		 * dao.saveProduct(entity);
		 */
		 
        
        //dao.updateProductById(1, 60000.00);
        ProductEntity product = dao.loadProductById(2);
        System.out.println(product);
        dao.deleteProductById(4);
    }
}

Composite primary key: (How to work when their is composite primary key)---->Combination of columns as primary key is known as Composite key
---------------------
+---------+----------+----------------+--------+     Roll number can't be primary key here as RollNo has duplicate values, but combination of RollNo and Section can't be repeated
| RollNo  | Section  | Name           | Marks  |
+---------+----------+----------------+--------+
| 101     | A        | Rohit Lavate   | 92     |
| 102     | A        | Mohammed Khan  | 88     |
| 101     | B        | Sneha Patil    | 95     |
| 103     | B        | Ajit Sharma    | 90     |
+---------+----------+----------------+--------+
-To work with Composite Id in JPA, we have to create two classes
1)Embeddable class
2)Entity Class
--Embeddable class should contain the variables to map with composite primary key columns. This class must implement Serializable interface
     @Embeddable
	 public class StudentComposteKey implements java.io.Serialiazable{
	   @Column(name = "rollno")
	   private Integer rollNumber;
	   @Column(name = "section")
	   private String section;
	   //Setter and Getter
	}
	
	 @Entity
	 @Table(name = "tbl_student")
	 public class StudentEntity{
	   @EmbeddedId
	   private StudentCompositeKey compositeKey;
	   
	   @Column(name = "sname")
	   private String studentName;
	   private Integer marks;
	  }

--Entity(i.e Object) State in JPA/Hibernate
-------------------------------------------
-Transient State-->When object created newly(not yet stored in db)
-Persistence State-->When called persist method and saved in db i.e Persist in db
-Detached State-->Once transaction completed and Close entitymanager(Object entered into detached state)
     -Whenever a new object is created for an entity class then that entity will be in transient state
	 -After setting the data to the entity, we are going to persist the entity to the database. Now the entity is in persistence state
	 -When entity manager is closed or when cleared or when an object is detached then, the entity enters into detached state
	 
	  StudentEntity student = new StudentEntity();      //Transient state
	  student.setStudentName("Pavan"); 
	  student.setMarks("450");
	  
	  EntityManager entityManager = factory.createEntityManager();
	  EntityTransaction tx = entityManager.getTransaction();
	  tx.begin();
	  entityManager.persist(employee);                  //Persistence state
	  
	  tx.commit();
	  entityManager.close();
	  //employee                                        //Detached state
	  
	  
                         ┌───────────────┐
                         │   Transient   │
                         │ (Not connected) │
                         └───────────────┘
                                  │
                                  │
                         ┌─────────────────────┐
                         │     EntityManager    │
                         │  (Manages entities)  │
                         └─────────────────────┘
                                  │
                                  ▼
                         ┌──────────────────────┐
                         │     Persistent       │
                         │ (Connected state —   │
                         │  entity associated   │
                         │  with EntityManager) │
                         └──────────────────────┘
                                  │
                                  │ (Entity goes out of
                                  │  EntityManager area)
                                  ▼
                         ┌──────────────────────┐
                         │      Detached        │
                         │ (Disconnected —       │
                         │  changes not saved   │
                         │  to database)        │
                         └──────────────────────┘
                                  │
                         (If reconnected via merge)
                                  │
                                  ▼
                         ┌──────────────────────┐
                         │     Persistent       │
                         │ (Connected again)    │
                         └──────────────────────┘

	  
                           ┌────────────┐
                           │  Transient │<--------------------new Object
                           └────────────┘
                                  │
                         persist() │
                                  ▼
                           ┌────────────┐
                           │ Persistent │
                           └────────────┘
                    ┌──────────┼───────────────┐
                    │          │               │
             remove()     detach()/clear()/   find() / getReference()
           (Marked for       close()          (Load from DB, goes to persistent state directly)
             deletion)          │               │
                    ▼            ▼               │
              ┌────────────┐ ┌────────────┐      │
              │  Removed   │ │  Detached  │◄─────┘
              └────────────┘ └────────────┘
                                  │
                               merge()
                                  ▼
                           ┌────────────┐
                           │ Persistent │
                           └────────────┘
						   

| **From → To**           | **Method / Action**              | **Result**                                       |
| ----------------------- | -------------------------------- | ------------------------------------------------ |
| Transient → Persistent  | `persist()`                      | Entity becomes managed.                          |
| Persistent → Detached   | `detach()`, `clear()`, `close()` | Entity no longer tracked.                        |
| Detached → Persistent   | `merge()`                        | Reattaches the entity (returns managed copy).    |
| Persistent → Removed    | `remove()`                       | Entity marked for deletion.                      |
| Removed → Deleted (DB)  | `commit()`                       | Entity physically deleted.                       |
| Persistent → Persistent | `find()` / `getReference()`      | Retrieves or references existing managed entity. |


| **State**      | **Meaning**                                                                                   |
| -------------- | --------------------------------------------------------------------------------------------- |
| **Transient**  | The object is new and **not managed** by the `EntityManager`. Not stored in the database.     |
| **Persistent** | The object is **managed** by the `EntityManager`; changes are synchronized with the database. |
| **Detached**   | The object was once persistent but is now **disconnected**. Changes won’t be saved.           |
| **Removed**    | The object is **marked for deletion** and will be removed from the database after commit.     |

------------------------------
public interface ProductDao {
	ProductEntity saveProduct(ProductEntity product);
	ProductEntity loadProductById(Integer productId);
	ProductEntity updateProductById(Integer productId,Double new_unitPrice);
	void deleteProductById(Integer productId);
	public void closeFactory();
	void testEntityStates();             //added method for understanding Entity States
}



	@Override
	public void testEntityStates() {
		EntityManager entityManager = factory.createEntityManager();
		
		ProductEntity pe = new ProductEntity();           //Transient State
		pe.setProductId(123);
		pe.setProductName("earbuds");
		pe.setQuantity(3);
		pe.setUnitPrice(2000.00);
		/*
		 * EntityTransaction tx = entityManager.getTransaction(); 
		 * tx.begin();
		 * entityManager.persist(pe); // persistence state 
		 * tx.commit();
		 * 
		 * entityManager.detach(pe); //Removed from cache 
		 * pe.setUnitPrice(3100.00);
		 * //changes made to an entity in detached state does not affect in db
		 * entityManager.close();
		 */
		
		ProductEntity entity = entityManager.find(ProductEntity.class, 123);  //entity is in persistence state(as loading from db)
		entityManager.detach(entity);                                         //detached state
		entity.setUnitPrice(3000.00);
		
		EntityTransaction tx = entityManager.getTransaction();
		tx.begin();
		entityManager.merge(entity);                                          //Moved from detailed to persistence state
		tx.commit();
		entityManager.close();
		
	}


--JPQL(Java Persistence Query Language)----->javax.persistence.query
---------------------------------------
-when we are using find(), remove()-->it happens on only one object
-For bulk operations-->to load or Update or delete multiple objects or bulk objects at a time from db-->we have to use queries(JPQL or SQL)
-JPQL queries are database independent and SQL queries are database dependent
-When we write a JPQL query, it will converted to SQL query with respect to the underlying db by the JPA provider(Hibernate)
-JPQL looks like SQL, but in place of table name provide entity class reference variable, and in place of column names, provide variable names
Example-->
           SQL Query--> select * from emp
		   JPQL Query--> select e from EmployeeEntity e  (e is entity class reference variable)  or
		                 from EmployeeEntity e (when selecting all attributes)
						 
		   SQL Query--> select ename,sal from emp
		   JPQL Query--> select e.employeeName,e.salary from EmployeeEntity e (when selecting specific column)
		   
		   SQL Query--> select * from emp where sal>?
		   JPQL Query--> select e from EmployeeEntity e where e.salary>?1    or                (Here ?1 is index parameter)
		                 from EmployeeEntity e where e.salary>?1
						 
		   SQL Query--> select * from emp where deptno=? and sal>?
		   JPQL Query--> select e from EmployeeEntity e where deptNumber=?1 and e.salary>?2   or
		                 from EmployeeEntity where e.deptNumber=?1 and e.salary>?2            or
						 from EmployeeEntity e where e.deptNumber=:dno and e.salary>:esal      (Here :dno,:esal are Named parameters--->Name can be anything)
						 
		   SQL Query--> update emp set sal=? where deptno=?
		   JPQL Query--> update EmployeeEntity e
		                 set e.salary=?1 where e.deptNumber=?2         or
						 
						 update EmployeeEntity each
						 set e.salary=:esal where e.deptNumber=:dno
						 
		   SQL Query--> select e.ename,d.dname from emp e
		                join dept d on e.deptno = d.deptno
		   JPQL Query-->select e.empName, d.deptName from EmployeeEntity e
		                join DepartmentEntity d on e.deptNumber=d.deptNumber
						
-How to run the JPQL Queries
-----------------------------
-Create Query(interface) object
-Set the Parameter values
-Execute it
Example:1)
        String jpql = "FROM EmployeeEntity e where e.deptNumber=?1";
		Query q = entityManager.createQuery(jpql);
		q.setParameter(1,20);                           //1 is parameter index, 20 is value
		List<EmployeeEntity> lst = q.getResultList();   //untyped list---->returns multiple entities from db
		
		2)
		Query q = entityManager.createQuery("From EmployeeEntity e where e.empNumber=:eno");
		q.setParameter("eno",7788);                     //Named Parameter
		Object o = q.getSingleResult();                 //retrieves single result(Need to cost it)
		EmployeeEntity e =(EmployeeEntity)obj;
		
--Instead of Query object, we can create TypedQuery object(TypedQuery is sub-interface of Query interface)
     https://docs.oracle.com/javaee/7/api/javax/persistence/TypedQuery.html--->To refer methods of TypedQuery
	 example:--> 1) getSingleResult() : Returns a single entity
	             2) getResultSet() : Returns multiple entities
				 3) executeUpdate() : to execute update/delete statements
--Query object returns untyped results, which means we need to do type casting the object into entity type.

Example of TypedQuery object:
        example 1:
          String jpqlQuery = "From EmployeeEntity e where e.empNumber=?1";
		  TypedQuery<EmployeeEntity> tq = entityManager.createQuery(jpqlQuery,EmployeeEntity.class);
		  tq.setParameter(1,7788);
		  EmployeeEntity emp = tq.getSingleResult();      //No Type casting required
		  
		example 2:
		  String jpqlQuery = "Update EmployeeEntity e set e.salary=:esal where e.deptNumber=:dno";
		  TypedQuery<Integer> tq = entityManager.createQuery(jpqlQuery,Integer.class);
		  tq.setParameter("esal",5400.00);
		  tq.setParameter("dno",20);
		  EntityTransaction tx = entityManager.getTransaction();
		  int count = tq.executeUpdate();
		  tx.commit();
		  
		example 3:
		  String jpqlQuery = "Select e.empName,e.salary from EmployeeEntity e";    //Query selects only particular columns
		  //selecting partial records
		  TypedQuery<Object> tq = createQuery(jpqlQuery,Object[].class);           //so use Object[]-->object array-->index 0(name), index 1(salary)
		  List<Object> list = tq.getResultList();
		  
---JPQL app
@Entity
@Table(name = "EMPLOYEE_DTLS")
public class EmployeeEntity {
	@Id
	@Column(name = "empno")
	private Integer empNumber;
	@Column(name = "ename")
	private String empName;
	@Column(name = "sal")
	private Double salary;
	@Column(name = "deptno")
	private Integer deptNumber;
	//getter,setter and toString()
}


public interface EmployeeDao {
	void insertEmployee(EmployeeEntity employee);
	void insertEmployeeUsingNativeQuery(Integer empNo, String empName, Double salary, Integer deptNo);
	EmployeeEntity fetchEmployeeById(Integer empno);
	List<EmployeeEntity> fetchEmployee();
	List<Object[]> fetchNamesAndSalaries();
}


public class AppConstants {
	public static final String QUERY_InsertEmployee = "INSERT INTO EMPLOYEE_DTLS (empno, ename, sal, deptno) VALUES (?, ?, ?, ?)";
	public static final String QUERY_fetchEmployeeById = "From EmployeeEntity e where e.empNumber=?1";
	public static final String QUERY_fetchEmployee = "From EmployeeEntity e";
	public static final String QUERY_fetchNamesAndSalaries = "select e.empName, e.salary from EmployeeEntity e";
}


public class EmployeeDaoImpl implements EmployeeDao{
	
	EntityManagerFactory factory = Persistence.createEntityManagerFactory("emp");
	
	@Override
	public void insertEmployee(EmployeeEntity employee) {
	    EntityManager entityManager = factory.createEntityManager();
	    entityManager.getTransaction().begin();
	    entityManager.persist(employee);
	    entityManager.getTransaction().commit();
	    entityManager.close();
	}
	
	@Override
	public void insertEmployeeUsingNativeQuery(Integer empNo, String empName, Double salary, Integer deptNo) {
		 EntityManager entityManager = factory.createEntityManager();
		    try {
		        entityManager.getTransaction().begin();
		        
		        entityManager.createNativeQuery(
		            AppConstants.QUERY_InsertEmployee)
		            .setParameter(1, empNo)
		            .setParameter(2, empName)
		            .setParameter(3, salary)
		            .setParameter(4, deptNo)
		            .executeUpdate();
		        
		        entityManager.getTransaction().commit();
		        System.out.println("✅ Employee inserted successfully!");
		    } catch (Exception e) {
		        entityManager.getTransaction().rollback();
		        e.printStackTrace();
		        System.err.println("❌ Failed to insert employee: " + e.getMessage());
		    } finally {
		        entityManager.close();
		    }
		
	}
	
	@Override
	public EmployeeEntity fetchEmployeeById(Integer empno) {
		EntityManager entityManager = factory.createEntityManager();
		TypedQuery<EmployeeEntity> tq = entityManager
				                 .createQuery(AppConstants.QUERY_fetchEmployeeById, EmployeeEntity.class);
		tq.setParameter(1, empno);
		EmployeeEntity e = tq.getSingleResult();
		entityManager.close();
		return e;
	}

	@Override
	public List<EmployeeEntity> fetchEmployee() {
		EntityManager entityManager = factory.createEntityManager();
		TypedQuery<EmployeeEntity> tq = entityManager.createQuery(AppConstants.QUERY_fetchEmployee, EmployeeEntity.class);
		List<EmployeeEntity> lstOfEmployees = tq.getResultList();
		entityManager.close();
		return lstOfEmployees;
	}

	@Override
	public List<Object[]> fetchNamesAndSalaries() {
		EntityManager em = factory.createEntityManager();
		TypedQuery<Object[]> tq = em.createQuery(AppConstants.QUERY_fetchNamesAndSalaries, Object[].class);
		List<Object[]> lst = tq.getResultList();
		em.close();
		return lst;
	}

}


public class ClientApp {
    public static void main(String[] args) {
        EmployeeDao dao = new EmployeeDaoImpl();
        
		/*
		 * EmployeeEntity employee = new EmployeeEntity(); 
		 * employee.setEmpNumber(103);
		 * employee.setEmpName("Ajay"); 
		 * employee.setSalary(55000.00);
		 * employee.setDeptNumber(1);
		 * 
		 * dao.insertEmployee(employee);
		 * 
		 * dao.insertEmployeeUsingNativeQuery(104, "Mayur", 57000.00, 1);
		 */
        EmployeeEntity fetchEmployeeById = dao.fetchEmployeeById(102);
        System.out.println(fetchEmployeeById);
        
        System.out.println("----------------------------------");
        
        List<EmployeeEntity> lst = dao.fetchEmployee();
        lst.forEach(System.out::println);
        
        System.out.println("----------------------------------");
        
        List<Object[]> fetchNamesAndSalaries = dao.fetchNamesAndSalaries();
        fetchNamesAndSalaries.forEach(obj-> 
        System.out.println(obj[0]+" "+obj[1]
        		));
    }
}
----------------------------------------------------------
-How to execute queries in JPA?
-------------------------------
For Select Query-->
        String sqlString = "select * from emp where deptno=?";
		Query q = entityManager.createNativeQuery(sqlString, EmployeeEntity.class);        //createNativeQuery is the overloaded method
		//Every record converted to result class
		q.setParameter(1,30);
		List lst = q.getResultList();
For Update Query-->
        String sqlString = "Update emp set sal=? where deptno=?";
		Query q = entityManager.createNativeQuery(sqlString);
		EntityTransaction tx = entityManager.getTransaction();
		tx.begin();
		int x = q.executeUpdate();     //For Insert, Update, Delete-->Call this method
		tx.commit();
		
Named Queries---> In Order to write Queries inside the Entity class(Reusablity)
-------------
Using Named Queries we can write our JPQL/SQL queries in entity class itself, so named queries will improve the readability of the queries
Using named queries, you can define entity class and your query in a single file
Example:
         @Entity
		 @Table(name="emp")
		 @NamedQuery(name="query1", query="From EmployeeEntity e Where e.deptNumber=?1")      //Annotation provided to define sql queries at entity class, here we used JPQL query
		 public class EmployeeEntity{
		     @Id
			 @Column(name = "empno")
             private Integer empNumber;
			 @Column(name = "ename")
             private String empName;
			 @Column(name = "sal")
			 private Double salary;
			 @Column(name = "deptno")
             private Integer deptNumber;
	}

To execute named query
          TypedQuery<EmployeeEntity> tq = entityManager.createNativeQuery("query1", EmployeeEntity.class);
		  tq.setParameter(1,40);
		  List<EmployeeEntity> lst = tq.getResultList();
		  
App
---
@Entity
@Table(name = "EMPLOYEE_DTLS")
@NamedQuery(name = "query1",query = "FROM EmployeeEntity e Where e.deptNumber=?")
@NamedNativeQuery(name = "query2",query = "select * from EMPLOYEE_DTLS where sal>?",resultClass = EmployeeEntity.class)
public class EmployeeEntity {
	@Id
	@Column(name = "empno")
	private Integer empNumber;
	@Column(name = "ename")
	private String empName;
	@Column(name = "sal")
	private Double salary;
	@Column(name = "deptno")
	private Integer deptNumber;
	//Getter setter
}


public interface EmpDao {
	List<EmployeeEntity> executeNamedQuery(int deptNo);
	List<EmployeeEntity> executeNamedQueryForSalary(int sal);
	List<EmployeeEntity> executeCriteriaQuery();                            //from this methods added later
	List<EmployeeEntity> executeCriteriaQueryForlessAndGreaterThan();
	List<EmployeeEntity> executeCriteriaQueryForInBetweenSalary();
}


public class EmpDaoImpl implements EmpDao {
	EntityManagerFactory factory = Persistence.createEntityManagerFactory("employee");

	@Override
	public List<EmployeeEntity> executeNamedQuery(int deptNo) {
		EntityManager em = factory.createEntityManager();
		TypedQuery<EmployeeEntity> q = em.createNamedQuery("query1", EmployeeEntity.class);
		q.setParameter(1, deptNo);
		List<EmployeeEntity> resultList = q.getResultList();
		em.close();
		return resultList;
	}

	@Override
	public List<EmployeeEntity> executeNamedQueryForSalary(int sal) {
		EntityManager em = factory.createEntityManager();
		try {
			Query q = em.createNamedQuery("query2");
			q.setParameter(1, sal);
			return q.getResultList(); // returns List<EmployeeEntity>
		} finally {
			em.close();
		}
	}

	@Override
	public List<EmployeeEntity> executeCriteriaQuery() {
		EntityManager em = factory.createEntityManager();
		CriteriaBuilder cb = em.getCriteriaBuilder();
		CriteriaQuery<EmployeeEntity> q = cb.createQuery(EmployeeEntity.class);
		Root<EmployeeEntity> r = q.from(EmployeeEntity.class);
		q.select(r).where(cb.gt(r.get("salary"), 55000));
		TypedQuery<EmployeeEntity> query = em.createQuery(q);
		List<EmployeeEntity> resultList = query.getResultList();
		em.close();
		return resultList;
	}

	@Override
	public List<EmployeeEntity> executeCriteriaQueryForlessAndGreaterThan() {
		EntityManager em = factory.createEntityManager();
		CriteriaBuilder cb = em.getCriteriaBuilder();
		CriteriaQuery<EmployeeEntity> q = cb.createQuery(EmployeeEntity.class);
		Root<EmployeeEntity> r = q.from(EmployeeEntity.class);
		q.select(r).where(cb.and(cb.gt(r.get("salary"), 52000), cb.lt(r.get("salary"), 58000)));

		List<EmployeeEntity> list = em.createQuery(q).getResultList();
		em.close();
		return list;
	}

	@Override
	public List<EmployeeEntity> executeCriteriaQueryForInBetweenSalary() {
		EntityManager em = factory.createEntityManager();

		CriteriaBuilder cb = em.getCriteriaBuilder();
		CriteriaQuery<EmployeeEntity> q = cb.createQuery(EmployeeEntity.class);
		Root<EmployeeEntity> r = q.from(EmployeeEntity.class);

		q.select(r).where(cb.between(r.get("salary"), 52000, 58000));

		List<EmployeeEntity> list = em.createQuery(q).getResultList();
		em.close();
		return list;
	}

}


public class AppClient {
    public static void main(String[] args) {
        EmpDao dao = new EmpDaoImpl();
        
        List<EmployeeEntity> executeNamedQuery = dao.executeNamedQuery(1);
        executeNamedQuery.forEach(System.out::println);
        
        System.out.println("----------------------------------------");
        
        List<EmployeeEntity> executeNamedQueryForSalary = dao.executeNamedQueryForSalary(54000);
        executeNamedQueryForSalary.forEach(System.out::println);
        
        System.out.println("----------------------------------------");
        
        List<EmployeeEntity> executeCriteriaQuery = dao.executeCriteriaQuery();
        executeCriteriaQuery.forEach(System.out::println);
        
        System.out.println("----------------------------------------");
        
        List<EmployeeEntity> executeCriteriaQueryForlessAndGreaterThan = dao.executeCriteriaQueryForlessAndGreaterThan();
        executeCriteriaQueryForlessAndGreaterThan.forEach(System.out::println);
        
        System.out.println("----------------------------------------");
        
        List<EmployeeEntity> executeCriteriaQueryForInBetweenSalary = dao.executeCriteriaQueryForInBetweenSalary();
        executeCriteriaQueryForInBetweenSalary.forEach(System.out::println);
    }
}
--Tuned and Untuned Queries
---------------------------
untuned--> select * from emp
tuned--> select empno,ename,sal,deptno from emp

untuned-->select empno, ename, sal, deptno from emp where sal>=3000 and sal<=5000
tuned-->select empno, ename, sal, deptno from emp where sal between 3000 and 5000;

--Criteria API--->code is present in above project
--------------
Criteria API allows you to build flexible, type-safe SQL-like queries using Java code instead of error-prone string queries.
Criteria API is a programmatic, type-safe, object-oriented way to build dynamic queries in JPA/Hibernate.Instead of writing JPQL/HQL as strings, you construct queries using Java classes and methods.
-Criteria API = Java way of building queries dynamically, using objects instead of strings
-Why Criteria API is used?
✔ 1. Dynamic Queries

If query conditions change at runtime (e.g., adding WHERE clauses dynamically).

✔ 2. Type Safe

Compiler checks your query; avoids errors like typo in column names.

✔ 3. No String-Based Query Errors

JPQL/HQL is string-based → easily breaks.
Criteria API → fully Java-based.

✔ 4. Easy to combine multiple filters

Example: filter by name, department, salary only if provided.

-CriteriaQuery Object--> Used in JPA to construct sql queries using Java methods
                     --CriteriaQuery Object can be used for only select operations
					 --CriteriaQuery object prepare tuned sql queries while executing, so the queries returns the data from Database fastly, so it improves the performance of an application
					 --CriteriaBuilder is a helper class, to construct CriteriaQuery object and also helps to construct the conditions
					 
					 CriteriaBuilder cb = em.getCriteriaBuilder();
					 //Selecting names and salaries of employees with CriteriaQuery
                     CriteriaQuery<Object[]> q = cb.createQuery(Object[].class);        //Type of the result     
					 //Root represents the entity used in select operation
                     Root<EmployeeEntity> r = q.from(EmployeeEntity.class);   
                     q.select(cb.array(r.get("empName"),r.get("empSal")));   
                     //CriteriaQuery object is converted to query Object for execution  					 					 
                     List<Object[]> lst = em.createQuery(q).getResultList();

Example: 1) JPQL vs Criteria API
JPQL-->
TypedQuery<EmployeeEntity> q = em.createQuery("SELECT e FROM EmployeeEntity e WHERE e.salary > :sal", EmployeeEntity.class);
q.setParameter("sal", 50000);

Same Query in Criteria API-->
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<EmployeeEntity> cq = cb.createQuery(EmployeeEntity.class);         
Root<EmployeeEntity> root = cq.from(EmployeeEntity.class);                      
cq.select(root).where(cb.greaterThan(root.get("salary"), 50000));               
TypedQuery<EmployeeEntity> query = em.createQuery(cq);
List<EmployeeEntity> results = query.getResultList();

Example: 2)
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Object[]> q = cb.createQuery(Object[].class);                      //Using CriteriaBuilder,create CriteriaQuery Object(CriteriaQuery constructs query based on Java methods i.e from(), select()) a proper tuned query,
Root<EmployeeEntity> r = q.from(EmployeeEntity.class);                           //then Create Root Object-->Represents what Entity class we used in query
q.select(cb.array(r.get("empName"),r.get("empSal")));                            //get the name and salary of EmployeeEntity i.e Root
List<Object[]> lst = em.createQuery(q).getResultList();                          //taken Object[] as we are selecting partial entity(i.e only part of record)

Example: 3)
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Person> q = cb.createQuery(Person.class);
Root<Person> p = q.from(Person.class);
q.select(p)
 .where(cb.isMember("joe", p.get("nicknames")));
List<Person> list = em.createQuery(q).getResultList();

Example: 4) IN clause
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Person> q = cb.createQuery(Person.class);
Root<Person> p = q.from(Person.class);
Path<Set<String>> nicknames = p.get("nicknames");
Predicate predicate = nicknames.in("joe", "sam", "mike");
q.select(p).where(predicate);
List<Person> result = em.createQuery(q).getResultList();

Example: 5)
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<EmployeeEntity> q = cb.createQuery(EmployeeEntity.class);
Root<EmployeeEntity> r = q.from(EmployeeEntity.class);
q.select(r)
 .where(cb.greaterThan(r.get("salary"), 3000.0));
List<EmployeeEntity> lst = em.createQuery(q).getResultList();


| Class                | Purpose                                               |
| -------------------- | ----------------------------------------------------- |
| **CriteriaBuilder**  | Factory for creating predicates, expressions, queries |
| **CriteriaQuery<T>** | Represents the full query                             |
| **Root<T>**          | Represents the table/entity                           |
| **Predicate**        | Conditions (WHERE clause)                             |
| **TypedQuery**       | Executable JPA query                                  |


🧠 When to Use Criteria API?

Use when:

✔ Query conditions are optional
✔ You want to add filters dynamically
✔ You want compile-time safety
✔ You are building complex queries (joins, grouping, subqueries)

🚀 Example: Dynamic Search with Multiple Optional Filters

CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<EmployeeEntity> cq = cb.createQuery(EmployeeEntity.class);
Root<EmployeeEntity> root = cq.from(EmployeeEntity.class);

List<Predicate> predicates = new ArrayList<>();

if (name != null) {
    predicates.add(cb.equal(root.get("empName"), name));
}

if (deptNo != null) {
    predicates.add(cb.equal(root.get("deptNumber"), deptNo));
}

if (minSalary != null) {
    predicates.add(cb.greaterThan(root.get("salary"), minSalary));
}

cq.where(predicates.toArray(new Predicate[0]));

TypedQuery<EmployeeEntity> query = em.createQuery(cq);
List<EmployeeEntity> list = query.getResultList();


| Feature                                             | Criteria API | JPQL   | Native SQL        |
| --------------------------------------------------- | ------------ | ------ | ----------------- |
| **Type Safe**                                       | ✅ Yes        | ❌ No   | ❌ No              |
| **Dynamic Queries**                                 | ⭐ Best       | ⚠ Hard | ⚠ Hard            |
| **Performance**                                     | Same as JPQL | Good   | Fastest sometimes |
| **Database Independent**                            | Fully        | Fully  | ❌ No              |
| **Ease to Write**                                   | ❌ Complex    | ⭐ Easy | ⚠ Medium          |
| **Complex SQL (joins, unions, analytic functions)** | Hard         | Hard   | ⭐ Best            |
| **Mapping Entities**                                | Yes          | Yes    | Yes               |
| **Raw table operations**                            | No           | No     | ⭐ Best            |


--Stored Procedure--> @NamedStoredProcedureQury and @StoredProcedureParameter
-------------------------------------------------------------------------------

CREATE TABLE EMP (
    EMPNO INT PRIMARY KEY,
    ENAME VARCHAR(100) NOT NULL,
    SAL DOUBLE NOT NULL,
    DEPTNO INT NOT NULL,
    DOJ DATE NOT NULL,
    MGR INT NULL,
    FOREIGN KEY (MGR) REFERENCES EMP(EMPNO)
);


INSERT INTO EMP VALUES
(7839, 'KING', 60000, 10, '2015-06-01', NULL);

INSERT INTO EMP VALUES
(7566, 'JONES', 50000, 20, '2018-11-10', 7839),
(7698, 'BLAKE', 48000, 30, '2017-05-03', 7839),
(7782, 'CLARK', 42000, 10, '2016-12-01', 7839);

INSERT INTO EMP VALUES
(7369, 'SMITH', 30000, 10, '2020-01-15', 7566),
(7499, 'ALLEN', 35000, 30, '2019-03-20', 7698),
(7521, 'WARD', 28000, 30, '2021-06-01', 7698);


select * from emp;



DELIMITER $$

CREATE PROCEDURE EMP_EXPERIENCE(
    IN ENO INT,
    OUT NAME VARCHAR(100),
    OUT EXPERIENCE DOUBLE
)
BEGIN
    DECLARE TEMP1 DATE;

    SELECT ENAME INTO NAME
    FROM EMP
    WHERE EMPNO = ENO;

    SELECT DOJ INTO TEMP1
    FROM EMP
    WHERE EMPNO = ENO;

    SET EXPERIENCE = TIMESTAMPDIFF(YEAR, TEMP1, CURDATE());
END $$

DELIMITER ;


@Entity
@Table(name = "emp")
@NamedStoredProcedureQuery(
        name = "emp_experience_proc",
        procedureName = "EMP_EXPERIENCE",

        parameters = {
                @StoredProcedureParameter(mode = ParameterMode.IN,  name = "ENO",        type = Integer.class),
                @StoredProcedureParameter(mode = ParameterMode.OUT, name = "NAME",       type = String.class),
                @StoredProcedureParameter(mode = ParameterMode.OUT, name = "EXPERIENCE", type = Double.class)
        }
)
public class EmployeeEntity {

    @Id
    @Column(name = "EMPNO")
    private int empNo;

    @Column(name = "ENAME")
    private String ename;

    @Column(name = "SAL")
    private double sal;

    @Column(name = "DEPTNO")
    private int deptNo;

    @Column(name = "DOJ")
    private java.sql.Date doj;

    @Column(name = "MGR")
    private Integer mgr;
	
	//getters and setters
}